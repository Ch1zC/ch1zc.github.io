[
    {
        "updateDate" : "2025年5月18日",
        "specificTtime" : "16点22分",
        "title": "0环境配置",
        "content" : "<h2>通过WSL下载与运行Ubuntu系统</h2><p>在Powershell中，查询供下载的系统版本</p><pre><code>wsl --list --online</code></pre><p>在一般情况下，列出的系统与版本中，以下版本对于制作操作系统而言是稳定且值得下载的：</p><pre><code>Ubuntu-22.04                    Ubuntu 22.04 LTS</code></pre><p>下载Ubuntu-22.04，命令将会有要求输入的部分，请在输入后不要行动，查看接下来的解释：</p><pre><code>wsl --install -d Ubuntu-22.04</code></pre><p><strong>请看完后再行动：</strong>上面的命令用于下载22.04版本的Ubuntu，在这期间，将提示新建一个新的UNIX账户：这相当于是可以执行sudo的Ubuntu普通用户。按照要求输入之后，你可以看到供你输入命令的命令提示符的出现，请<strong>不要着急输入什么</strong>，只是等待十秒钟时间（通常其内部无需这么久来处理信息，只是保守一点的等待方法），随后关闭窗口或者输入<code>exit</code>。</p><p>虽然不是必须的，到这一步可以选择性将电脑重新启动，以应用WSL的变化。</p><p>重新启动之后再度进入Powershell，输入以下命令以启动Ubuntu-22.04（参数<code>-d</code>以开启指定系统）：</p><pre><code>wsl -d Ubuntu-22.04</code></pre><p>一般来说是可以正确进入Ubuntu操作系统的，现在我们可以将其设置为默认启动系统，以后仅需输入<code>wsl</code>即可开启它：</p><pre><code>wsl --set-default Ubuntu-22.04</code></pre><p>如果有多个Ubuntu实例，可以通过以下命令列出设备上已有的系统：</p><pre><code>wsl --list --verbose</code></pre><p>如果想要删掉某个系统实例，可以通过以下命令实现，<strong>删错无法恢复，需谨慎</strong>：</p><pre><code>wsl --unregister &lt;上一条命令中的NAME值&gt;</code></pre><p>没有特殊需求到这里就可以结束了。</p><h2>迁移Ubuntu系统实例</h2><p>由于WSL默认安装在C盘，对于想要节省C盘空间的人来说迁移Ubuntu系统到其他盘符显得尤为重要。</p><p>请先创建两个目录，目录A用于存放<code>导出后的Ubuntu的压缩包</code>，目录B用于存放<code>解压Ubuntu压缩包后的数据</code>，目录B装的是以后都要运行的系统实例，不能删除，目录A可以，因为只是导出的Ubuntu系统。</p><p>我们要先：导出指定Ubuntu系统实例为压缩包存放到目录A里。</p><p>随后需要：导入目录A中的Ubuntu系统实例压缩包，并作为新的实例，指定其实例名称，以及指定其存放位置为目录B</p><p>让我们开始迁移：</p><p>导出Ubuntu实例作为一个压缩包，将这个压缩包命名，随后指定这个压缩包放的地方为目录A：</p><pre><code>wsl --export Ubuntu-22.04 &lt;目录A的路径&gt;\\install.tar.gz</code></pre><p>导出完毕后，指定从目录A中导入压缩包，并作为新的Ubuntu实例，定义其名称和存放位置为目录B：</p><pre><code>wsl --import &lt;新的实例名称&gt; &lt;目录B的路径&gt; &lt;目录A的路径&gt;\\install.tar.gz</code></pre><p>在删除还存留在C盘的Ubuntu实例之前，建议先确认在迁移到其他盘符后的Ubuntu实例是可以正常运行的：</p><pre><code>wsl -d &lt;新的实例名称&gt;</code></pre><p>如果的确是可以正常运行的，即可删除还留存在C盘中的Ubuntu实例：</p><p>利用<code>wsl --list --verbose</code>查询所有可用实例，确认所要删除的实例，也就是除了&lt;新的实例名称&gt;以外的所有</p><p>利用<code>wsl --unregister &lt;上一条命令中的NAME值&gt;</code>以删除指定NAME的实例。</p><p>结束。</p>",
        "type" : 0
    },
    {
        "updateDate" : "2025年5月18日",
        "specificTtime" : "13点19分",
        "title": "1引导扇区文件",
        "content" : "<h2>构建引导扇区文件(Boot sector)</h2><p>BIOS需要知道如何启动系统，所以它会将这个任务交给引导扇区文件执行，一个引导扇区文件有512字节。</p><p>我们将编写一个包含死循环的引导扇区文件，因为死循环所以它不会做任何事情，不过它会新建一个提示“Booting from Hard Disk...”的窗口，但是因为它是什么都不做的，所以永远不会有下一步。</p><h3>下载所需工具</h3><p>编辑<code>/etc/apt/sources.list</code>文件，将以下网络源替代该文件的所有原始内容：</p><pre><code>deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-updates main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-backports main restricted universe multiverse<br>deb http://mirrors.aliyun.com/ubuntu/ jammy-security main restricted universe multiverse</code></pre><p>随后<code>apt update</code>应用更新，并下载所需要的工具：</p><pre><code>sudo apt install build-essential nasm git qemu-system-i386</code></pre><h3>开始编写</h3><p>新建工程文件，在其中新建一个以 <code>.asm</code> 为后缀的 汇编源文件，这将会作为我们什么都不做的引导扇区文件。</p><p>输入以下内容：</p><pre><code>loop:<br>&nbsp;&nbsp;&nbsp;&nbsp;jmp loop<br><br>times 510-($-$$) db 0<br>dw 0xaa55</code></pre><p>引导扇区文件规定：一个引导扇区文件的大小必须是512字节，除了在开头编写它真正要做的部分，其他都以<code>0</code>占空，最后末尾两位为“魔数”，BIOS将根据魔数来判断这个引导扇区是不是可引导的。</p><p><code>loop: jmp loop</code>是引导扇区真正做的事情：无限循环这个过程：<code>陷入循环，跳转到循环入口，陷入循环</code>，也就达到了我们“什么都不做”的目的。</p><p><code>times 510-($-$$) db 0</code>的作用是填补<code>0</code>：<code>($ - $$)</code>中的<code>$</code>为前面写了多少个字节，<code>$$</code>为文件的开头位置，这一般为0。所以<code>times</code>通过计算<code>510-($-$$)</code>后，这段代码将：偏移3个字节位置（<code>loop : jmp loop</code>占三个字节）也就是从<code>510-(3 - 0)</code>的下一个位置开始，到第510之间的所有空间都填补<code>0</code>。</p><p><code>dw 0xaa55</code> 的作用是在511和512的位置上分别写入<code>55</code>和<code>aa</code>，也被称之为魔数，它会将该扇区标记为合法引导扇区。</p><h3>编译</h3><p>将汇编文件（.asm）编译为二进制（.bin）：</p><pre><code>nasm -f bin &lt;asm文件&gt;.asm -o &lt;编译后新文件的名称&gt;.bin</code></pre><h3>运行</h3><pre><code>qemu-system-i386 -drive format=raw,file=&lt;编译后新文件的名称&gt;.bin</code></pre><p>正常情况下可以看到一个名为QEMU的新窗口弹出，并且一直显示“Booting from Hard Disk...”且没有下一步。</p><p>结束。</p>",
        "type" : 0
    },
    {
        "updateDate" : "2025年5月17日",
        "specificTtime" : "13点21分",
        "title": "2内存偏移量",
        "content" : "<h2>内存偏移量</h2><p>设定内存偏移量是一串在汇编源代码文件中常见的代码，它在大多数情况下在汇编文件的第一行，并长这样：</p><pre><code>[org 0x7c00]</code></pre><p><code>0x7c00</code>是值，其代表内存偏移量究竟要偏移多少。<strong>请注意：</strong>这个值并不是想设置多少就设置多少的，它在大多数情况下值都是<code>0x7c00</code>。</p><p>设定内存偏移量的目的很简单，我们之前编写了一个什么都不做的引导扇区文件，它是汇编编写的，随后我们将其编译为了二进制文件，随后使用<code>qemu-system-i386</code>执行了编译后的二进制文件，这不是重点，请耐心看到后面。</p><p>我们现在有两个文件：汇编文件、引导扇区二进制文件。对于汇编文件而言，在不设定内存偏移量时，汇编器将默认认为程序是从内存位置<code>0x0000</code>开始运行，这样任何涉及到寻址的代码都将相对于<code>0x0000</code>找寻，一切都是正常的。而对于引导扇区二进制文件，BIOS将会把这个二进制文件直接copy paste到内存位置<code>0x7c00</code>后开始执行，对，如果这个时候不设定内存偏移量的话，汇编器将依然认为程序是从内存位置<code>0x0000</code>开始运行的，接下来任何涉及到寻址的代码都还会相对于<code>0x0000</code>找寻而不是<code>0x7c00</code>，这样的后果是找不到内容或者是找到垃圾内存，导致黑屏或者花屏，这也是为什么我说内存偏移量的值<code>它在大多数情况下值都是0x7c00</code>的原因。</p><p>我可以写一个执行过程图加深印象：</p><p><strong>汇编代码（不设定内存偏移量）</strong>：运行代码 -- 执行到需要去寻址的代码 -- 未检测到设定内存偏移量，汇编器将默认从<code>0x0000</code>开始寻址 -- 根据寻址标签的类型使用专门的计算方法，并在<code>内存偏移量</code>和<code>该标签距离文件头部的字节数</code>的参与下算出目标所处的内存位置 -- 得到值，继续执行 -- 没问题</p><p><strong>二进制代码（汇编未设定内存偏移量）</strong>：文件被BIOS copy paste到内存位置<code>0x7c00</code> -- 执行到需要去寻址的代码 -- 未检测到设定内存偏移量，汇编器将默认从<code>0x0000</code>开始寻址 -- 根据寻址标签的类型使用专门的计算方法，并在<code>内存偏移量</code>和<code>该标签距离文件头部的字节数</code>的参与下算出目标所处的内存位置 -- 找不到数据/找到的是垃圾内存 -- 无法正常执行</p><p><strong>如果设定了内存偏移量，并为<code>0x7c00</code>：</strong></p><p><strong>汇编代码</strong>：运行代码 -- 执行到需要去寻址的代码 -- 检测到内存偏移量被指定为<code>0x7c00</code>，汇编器将从<code>0x7c00</code>开始寻址 -- 根据寻址标签的类型使用专门的计算方法，并在<code>内存偏移量</code>和<code>该标签距离文件头部的字节数</code>的参与下算出目标所处的内存位置 -- 得到值，继续执行 -- 没问题</p><p><strong>二进制代码</strong>：文件被BIOS copy paste到内存位置<code>0x7c00</code> -- 执行到需要去寻址的代码 -- 检测到内存偏移量被指定为<code>0x7c00</code>，汇编器将从<code>0x7c00</code>开始寻址 -- 根据寻址标签的类型使用专门的计算方法，并在<code>内存偏移量</code>和<code>该标签距离文件头部的字节数</code>的参与下算出目标所处的内存位置 -- 得到值，继续执行 -- 没问题</p><p>说白了，<strong>内存偏移量的作用是使汇编和二进制文件的内存起点一致（都为<code>0x7c00</code> ）</strong></p><p>但你应该注意到我们之前的代码没有设定内存偏移量但依然可以执行，这是因为只有在使用了特定的代码，比如标签、跳转等功能时才会需要用到它，我们之前做的不过是一个死循环引导扇区文件，根本没有复杂到这个程度，所以才没有用到。不过这依然是一个很有用的东西，即使我们现在没有用到，但只要想做一个出色的系统，这肯定是会用到的。</p><p>结束。</p>",
        "type" : 0
    }
]